import ast
from typing import Any, Callable, Dict as tDict, List, Optional, Tuple as tTuple, Union as tUnion

null = ...
TOKEN = tTuple[int, str]
DICT = tDict[str, Any]
TRANS = Callable[[List[TOKEN], DICT, DICT], List[TOKEN]]
class ParenthesisGroup(List[TOKEN]):
    ...


class AppliedFunction:
    def __init__(self, function: TOKEN, args: ParenthesisGroup, exponent=...) -> None:
        ...
    
    def expand(self) -> List[TOKEN]:
        ...
    
    def __getitem__(self, index) -> Any:
        ...
    
    def __repr__(self) -> str:
        ...
    


def function_exponentiation(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]:
    ...

def split_symbols_custom(predicate: Callable[[str], bool]) -> Callable[..., list[TOKEN]]:
    ...

split_symbols = ...
def implicit_multiplication(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> List[TOKEN]:
    ...

def implicit_application(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> List[TOKEN]:
    ...

def implicit_multiplication_application(result: List[TOKEN], local_dict: DICT, global_dict: DICT) -> List[TOKEN]:
    ...

def auto_symbol(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]:
    ...

def lambda_notation(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]:
    ...

def factorial_notation(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]:
    ...

def convert_xor(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]:
    ...

def repeated_decimals(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]:
    ...

def auto_number(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]:
    ...

def rationalize(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]:
    ...

def convert_equals_signs(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> List[TOKEN]:
    ...

standard_transformations: tTuple[TRANS, ...] = ...
def stringify_expr(s: str, local_dict: DICT, global_dict: DICT, transformations: tTuple[TRANS, ...]) -> str:
    ...

def eval_expr(code, local_dict: DICT, global_dict: DICT) -> Any:
    ...

def parse_expr(s: str, local_dict: Optional[DICT] = ..., transformations: tUnion[tTuple[TRANS, ...], str] = ..., global_dict: Optional[DICT] = ..., evaluate=...) -> Any:
    ...

def evaluateFalse(s: str) -> ast.Expression:
    ...

class EvaluateFalseTransformer(ast.NodeTransformer):
    operators = ...
    functions = ...
    relational_operators = ...
    def visit_Compare(self, node) -> ast.Call | ast.Compare:
        ...
    
    def flatten(self, args, func) -> list[Any]:
        ...
    
    def visit_BinOp(self, node) -> ast.Call | ast.BinOp:
        ...
    
    def visit_Call(self, node) -> ast.AST:
        ...
    


_transformation = ...
transformations = ...
class _T:
    def __init__(self) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __getitem__(self, t) -> tuple[Any, ...]:
        ...
    


T = ...
