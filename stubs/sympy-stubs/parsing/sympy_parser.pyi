import ast
from typing import Any, Callable, Dict as tDict, List, Optional, Tuple as tTuple, Union as tUnion

null = ...
TOKEN = tTuple[int, str]
DICT = tDict[str, Any]
TRANS = Callable[[List[TOKEN], DICT, DICT], List[TOKEN]]

class ParenthesisGroup(List[TOKEN]): ...

class AppliedFunction:
    def __init__(self, function: TOKEN, args: ParenthesisGroup, exponent=...) -> None: ...
    def expand(self) -> List[TOKEN]: ...
    def __getitem__(self, index) -> Any: ...
    def __repr__(self) -> str: ...

def function_exponentiation(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def split_symbols_custom(predicate: Callable[[str], bool]) -> Callable[..., list[TOKEN]]: ...

split_symbols = ...

def implicit_multiplication(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> List[TOKEN]: ...
def implicit_application(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> List[TOKEN]: ...
def implicit_multiplication_application(result: List[TOKEN], local_dict: DICT, global_dict: DICT) -> List[TOKEN]: ...
def auto_symbol(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def lambda_notation(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def factorial_notation(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def convert_xor(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def repeated_decimals(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def auto_number(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def rationalize(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> list[TOKEN]: ...
def convert_equals_signs(tokens: List[TOKEN], local_dict: DICT, global_dict: DICT) -> List[TOKEN]: ...

standard_transformations: tTuple[TRANS, ...] = ...

def stringify_expr(s: str, local_dict: DICT, global_dict: DICT, transformations: tTuple[TRANS, ...]) -> str: ...
def eval_expr(code, local_dict: DICT, global_dict: DICT) -> Any: ...
def parse_expr(
    s: str,
    local_dict: Optional[DICT] = ...,
    transformations: tUnion[tTuple[TRANS, ...], str] = ...,
    global_dict: Optional[DICT] = ...,
    evaluate=...,
) -> Any: ...
def evaluateFalse(s: str) -> ast.Expression: ...

class EvaluateFalseTransformer(ast.NodeTransformer):
    operators = ...
    functions = ...
    relational_operators = ...
    def visit_Compare(self, node) -> ast.Call | ast.Compare: ...
    def flatten(self, args, func) -> list[Any]: ...
    def visit_BinOp(self, node) -> ast.Call | ast.BinOp: ...
    def visit_Call(self, node) -> ast.AST: ...

_transformation = ...
transformations = ...

class _T:
    def __init__(self) -> None: ...
    def __str__(self) -> str: ...
    def __getitem__(self, t) -> tuple[Any, ...]: ...

T = ...
