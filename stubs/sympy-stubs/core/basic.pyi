from typing import Any, Literal
from typing_extensions import Self

from sympy import Symbol
from sympy.core._print_helpers import Printable
from sympy.core.cache import cacheit
from sympy.core.kind import Kind

def as_Basic(expr): ...

class Basic(Printable):
    __slots__ = ...
    _args: tuple[Basic, ...]
    _mhash: int | None
    @property
    def __sympy__(self) -> Literal[True]: ...
    def __init_subclass__(cls) -> None: ...

    is_number = ...
    is_Atom = ...
    is_Symbol = ...
    is_symbol = ...
    is_Indexed = ...
    is_Dummy = ...
    is_Wild = ...
    is_Function = ...
    is_Add = ...
    is_Mul = ...
    is_Pow = ...
    is_Number = ...
    is_Float = ...
    is_Rational = ...
    is_Integer = ...
    is_NumberSymbol = ...
    is_Order = ...
    is_Derivative = ...
    is_Piecewise = ...
    is_Poly = ...
    is_AlgebraicNumber = ...
    is_Relational = ...
    is_Equality = ...
    is_Boolean = ...
    is_Not = ...
    is_Matrix = ...
    is_Vector = ...
    is_Point = ...
    is_MatAdd = ...
    is_MatMul = ...
    is_real: bool | None
    is_extended_real: bool | None
    is_zero: bool | None
    is_negative: bool | None
    is_commutative: bool | None
    kind: Kind = ...
    def __new__(cls, *args) -> Self: ...
    def copy(self) -> Self: ...
    def __getnewargs__(self) -> tuple[Basic, ...]: ...
    def __getstate__(self) -> None: ...
    def __setstate__(self, state) -> None: ...
    def __reduce_ex__(self, protocol) -> str | tuple[Any, ...]: ...
    def __hash__(self) -> int: ...
    @property
    def assumptions0(self) -> dict[Any, Any]: ...
    def compare(self, other) -> int: ...
    @classmethod
    def fromiter(cls, args, **assumptions) -> Self: ...
    @classmethod
    def class_key(cls) -> tuple[Literal[5], Literal[0], str]: ...
    @cacheit
    def sort_key(self, order=...) -> tuple[tuple[Literal[5], Literal[0], str], tuple[int, tuple[Any, ...]], Any, Any]: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def dummy_eq(self, other, symbol=...): ...
    def atoms(self, *types) -> set[Any]: ...
    @property
    def free_symbols(self) -> set[Basic]: ...
    @property
    def expr_free_symbols(self) -> set[Any]: ...
    def as_dummy(self) -> Self | tuple[Any, dict[Any, Any]]: ...
    @property
    def canonical_variables(self) -> dict[Any, Any]: ...
    def rcall(self, *args) -> Symbol | Any: ...
    def is_hypergeometric(self, k) -> bool | None: ...
    @property
    def is_comparable(self) -> Literal[False]: ...
    @property
    def func(self) -> type[Self]: ...
    @property
    def args(self) -> tuple[Basic, ...]: ...
    def as_content_primitive(self, radical=..., clear=...) -> tuple[Any, Self]: ...
    def subs(self, *args, **kwargs) -> Self | Basic: ...
    def xreplace(self, rule) -> Self: ...
    @cacheit
    def has(self, *patterns) -> bool: ...
    def has_xfree(self, s: set[Basic]) -> bool: ...
    @cacheit
    def has_free(self, *patterns) -> bool: ...
    def replace(self, query, value, map=..., simultaneous=..., exact=...) -> tuple[Any, dict[Any, Any]]: ...
    def find(self, query, group=...) -> set[Any] | dict[Any, Any]: ...
    def count(self, query) -> int: ...
    def matches(self, expr, repl_dict=..., old=...) -> dict[Any, Any] | None: ...
    def match(self, pattern, old=...): ...
    def count_ops(self, visual=...): ...
    def doit(self, **hints) -> Self: ...
    def simplify(self, **kwargs): ...
    def refine(self, assumption=...) -> Basic: ...
    def rewrite(self, *args, deep=..., **hints) -> Self | Any: ...

    _constructor_postprocessor_mapping = ...
    def could_extract_minus_sign(self) -> Literal[False]: ...

class Atom(Basic):
    is_Atom = ...
    __slots__ = ...
    def matches(self, expr, repl_dict=..., old=...) -> dict[Any, Any] | None: ...
    def xreplace(self, rule, hack2=...): ...
    def doit(self, **hints) -> Self: ...
    @classmethod
    def class_key(cls) -> tuple[Literal[2], Literal[0], str]: ...
    @cacheit
    def sort_key(self, order=...) -> tuple[tuple[Literal[2], Literal[0], str], tuple[Literal[1], tuple[str]], Any, Any]: ...

preorder_traversal = ...
