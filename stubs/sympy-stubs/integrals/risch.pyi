from typing import Any, Literal

from sympy.core.relational import Equality, Ne, Relational
from sympy.integrals.integrals import Integral

def integer_powers(exprs) -> list[tuple[Any, Any]]: ...

class DifferentialExtension:
    __slots__ = ...
    def __init__(self, f=..., x=..., handle_first=..., dummy=..., extension=..., rewrite_complex=...) -> None: ...
    def __getattr__(self, attr) -> None: ...
    def __eq__(self, other) -> bool: ...
    def reset(self) -> None: ...
    def indices(self, extension) -> list[int]: ...
    def increment_level(self) -> None: ...
    def decrement_level(self) -> None: ...

def update_sets(seq, atoms, func) -> list[Any]: ...

class DecrementLevel:
    __slots__ = ...
    def __init__(self, DE) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type, exc_value, traceback) -> None: ...

class NonElementaryIntegralException(Exception): ...

def gcdex_diophantine(a, b, c) -> tuple[Any, Any]: ...
def frac_in(f, t, *, cancel=..., **kwargs) -> tuple[Any, Any]: ...
def as_poly_1t(p, t, z): ...
def derivation(p, DE, coefficientD=..., basic=...) -> Any | Literal[0]: ...
def get_case(d, t) -> Literal["base", "primitive", "exp", "tan", "other_nonlinear", "other_linear"]: ...
def splitfactor(p, DE, coefficientD=..., z=...) -> tuple[Any, Any]: ...
def splitfactor_sqf(
    p, DE, coefficientD=..., z=..., basic=...
) -> tuple[tuple[tuple[Any, Literal[1]]], tuple[()]] | tuple[tuple[Any, ...], tuple[Any, ...]]: ...
def canonical_representation(a, d, DE) -> tuple[Any, tuple[Any, Any], tuple[Any, Any]]: ...
def hermite_reduce(a, d, DE) -> tuple[tuple[Any, Any], tuple[Any, Any], tuple[Any, Any]]: ...
def polynomial_reduce(p, DE) -> tuple[Any, Any]: ...
def laurent_series(a, d, F, n, DE) -> tuple[Any, Any, list[Any]] | Literal[0]: ...
def recognize_derivative(a, d, DE, z=...) -> bool: ...
def recognize_log_derivative(a, d, DE, z=...) -> bool: ...
def residue_reduce(a, d, DE, z=..., invert=...) -> tuple[list[Any], Literal[True]] | tuple[list[Any], bool]: ...
def residue_reduce_to_basic(H, DE, z) -> int: ...
def residue_reduce_derivation(H, DE, z): ...
def integrate_primitive_polynomial(p, DE) -> tuple[Any, Any, Literal[True]] | tuple[Any, Any, Literal[False]]: ...
def integrate_primitive(
    a, d, DE, z=...
) -> (
    tuple[Any, Any | Equality | Relational | Ne | NonElementaryIntegral, Literal[False]]
    | tuple[Any, Any | Equality | Relational | Ne | NonElementaryIntegral, bool]
): ...
def integrate_hyperexponential_polynomial(p, DE, z) -> tuple[Any, Any, Literal[True]] | tuple[Any, Any, bool]: ...
def integrate_hyperexponential(
    a, d, DE, z=..., conds=...
) -> (
    tuple[Any, Any | Equality | Relational | Ne | NonElementaryIntegral, Literal[False]]
    | tuple[Any, Any | Equality | Relational | Ne | NonElementaryIntegral, bool]
): ...
def integrate_hypertangent_polynomial(p, DE) -> tuple[Any, Any]: ...
def integrate_nonlinear_no_specials(a, d, DE, z=...) -> tuple[Any, Literal[False]] | tuple[Any, bool]: ...

class NonElementaryIntegral(Integral): ...

def risch_integrate(
    f, x, extension=..., handle_first=..., separate_integral=..., rewrite_complex=..., conds=...
) -> tuple[Any, NonElementaryIntegral] | tuple[Any, Literal[0]] | None: ...
