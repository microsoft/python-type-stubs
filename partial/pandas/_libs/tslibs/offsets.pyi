from __future__ import annotations
from datetime import datetime
from typing import Tuple, Union
from datetime import timedelta

class BaseOffset:

    def __init__(self, n: int = ..., normalize: bool = ...) -> None: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    @property
    def kwds(self) -> dict: ...
    @property
    def base(self) -> BaseOffset: ...
    def __add__(self, other) -> BaseOffset: ...
    def __sub__(self, other) -> BaseOffset: ...
    def __call__(self, other): ...
    def __mul__(self, other): ...
    def __neg__(self) -> BaseOffset: ...
    def copy(self) -> BaseOffset: ...
    def __repr__(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def rule_code(self) -> str: ...
    def freqstr(self) -> str: ...
    # Next one is problematic due to circular imports
    #def apply_index(self, dtindex: DatetimeIndex) -> DatetimeIndex: ...
    def apply_index(self, dtindex): ...
    def _apply_array(self, dtarr) -> None: ...
    def rollback(self, dt: datetime) -> datetime: ...
    def rollforward(self, dt: datetime) -> datetime: ...
    def is_on_offset(self, dt: datetime) -> bool: ...
    def __setstate__(self, state) -> None: ...
    def __getstate__(self): ...
    @property
    def nanos(self) -> int: ...
    def onOffset(self, dt: datetime) -> bool: ...
    def isAnchored(self) -> bool: ...
    def is_anchored(self) -> bool: ...

class SingleConstructorOffset(BaseOffset):
    @classmethod
    def _from_name(cls, suffix=None): ...
    def __reduce__(self): ...

def to_offset(freq: Union[str, Tuple, timedelta, BaseOffset, None]) -> Union[BaseOffset, None]: ...

