import datetime
import numpy as np
from typing import Any, Callable, Iterable, Literal, Sequence
from matplotlib._typing import *
from matplotlib.font_manager import FontProperties

"""
This type stub file was generated by pyright.
"""

import enum
import functools
from . import _api

"""
This type stub file was generated by pyright.
"""

def get_unicode_index(symbol: str, math: bool = ...):
    r"""
    Return the integer index (from the Unicode table) of *symbol*.

    Parameters
    ----------
    symbol : str
        A single (Unicode) character, a TeX command (e.g. r'\pi') or a Type1
        symbol name (e.g. 'phi').
    math : bool, default: True
        If False, always treat as a single Unicode character.
    """
    ...

class Fonts:
    """
    An abstract base class for a system of fonts to use for mathtext.

    The class must be able to take symbol keys and font file names and
    return the character metrics.  It also delegates to a backend class
    to do the actual drawing.
    """

    def __init__(self, default_font_prop, mathtext_backend) -> None:
        """
        Parameters
        ----------
        default_font_prop : `~.font_manager.FontProperties`
            The default non-math font, or the base font for Unicode (generic)
            font rendering.
        mathtext_backend : `MathtextBackend` subclass
            Backend to which rendering is actually delegated.
        """
        ...
    def get_kern(
        self,
        font1,
        fontclass1,
        sym1,
        fontsize1,
        font2,
        fontclass2,
        sym2,
        fontsize2,
        dpi,
    ):
        """
        Get the kerning distance for font between *sym1* and *sym2*.

        See `~.Fonts.get_metrics` for a detailed description of the parameters.
        """
        ...
    def get_metrics(
        self, font: str, font_class: str, sym: str, fontsize: float, dpi: float
    ) -> object:
        r"""
        Parameters
        ----------
        font : str
            One of the TeX font names: "tt", "it", "rm", "cal", "sf", "bf",
            "default", "regular", "bb", "frak", "scr".  "default" and "regular"
            are synonyms and use the non-math font.
        font_class : str
            One of the TeX font names (as for *font*), but **not** "bb",
            "frak", or "scr".  This is used to combine two font classes.  The
            only supported combination currently is ``get_metrics("frak", "bf",
            ...)``.
        sym : str
            A symbol in raw TeX form, e.g., "1", "x", or "\sigma".
        fontsize : float
            Font size in points.
        dpi : float
            Rendering dots-per-inch.

        Returns
        -------
        object

            The returned object has the following attributes (all floats,
            except *slanted*):

            - *advance*: The advance distance (in points) of the glyph.
            - *height*: The height of the glyph in points.
            - *width*: The width of the glyph in points.
            - *xmin*, *xmax*, *ymin*, *ymax*: The ink rectangle of the glyph
            - *iceberg*: The distance from the baseline to the top of the
              glyph.  (This corresponds to TeX's definition of "height".)
            - *slanted*: Whether the glyph should be considered as "slanted"
              (currently used for kerning sub/superscripts).
        """
        ...
    def render_glyph(self, ox, oy, font, font_class, sym, fontsize, dpi):
        """
        At position (*ox*, *oy*), draw the glyph specified by the remaining
        parameters (see `get_metrics` for their detailed description).
        """
        ...
    def render_rect_filled(self, x1, y1, x2, y2):
        """
        Draw a filled rectangle from (*x1*, *y1*) to (*x2*, *y2*).
        """
        ...
    def get_xheight(self, font, fontsize, dpi):
        """
        Get the xheight for the given *font* and *fontsize*.
        """
        ...
    def get_underline_thickness(self, font, fontsize, dpi):
        """
        Get the line thickness that matches the given font.  Used as a
        base unit for drawing lines such as in a fraction or radical.
        """
        ...
    def get_used_characters(self):
        """
        Get the set of characters that were used in the math
        expression.  Used by backends that need to subset fonts so
        they know which glyphs to include.
        """
        ...
    def get_sized_alternatives_for_symbol(self, fontname, sym):
        """
        Override if your font provides multiple sizes of the same
        symbol.  Should return a list of symbols matching *sym* in
        various sizes.  The expression renderer will select the most
        appropriate size for a given situation from this list.
        """
        ...

class TruetypeFonts(Fonts):
    """
    A generic base class for all font setups that use Truetype fonts
    (through FT2Font).
    """

    def __init__(self, default_font_prop, mathtext_backend) -> None: ...
    def get_xheight(self, fontname, fontsize, dpi): ...
    def get_underline_thickness(self, font, fontsize, dpi): ...
    def get_kern(
        self,
        font1,
        fontclass1,
        sym1,
        fontsize1,
        font2,
        fontclass2,
        sym2,
        fontsize2,
        dpi,
    ): ...

class BakomaFonts(TruetypeFonts):
    """
    Use the Bakoma TrueType fonts for rendering.

    Symbols are strewn about a number of font files, each of which has
    its own proprietary 8-bit encoding.
    """

    def __init__(self, *args, **kwargs) -> None: ...
    def get_sized_alternatives_for_symbol(self, fontname, sym): ...

class UnicodeFonts(TruetypeFonts):
    """
    An abstract base class for handling Unicode fonts.

    While some reasonably complete Unicode fonts (such as DejaVu) may
    work in some situations, the only Unicode font I'm aware of with a
    complete set of math symbols is STIX.

    This class will "fallback" on the Bakoma fonts when a required
    symbol can not be found in the font.
    """

    def __init__(self, *args, **kwargs) -> None: ...
    def get_sized_alternatives_for_symbol(self, fontname, sym): ...

class DejaVuFonts(UnicodeFonts):
    def __init__(self, *args, **kwargs) -> None: ...

class DejaVuSerifFonts(DejaVuFonts):
    """
    A font handling class for the DejaVu Serif fonts

    If a glyph is not found it will fallback to Stix Serif
    """

class DejaVuSansFonts(DejaVuFonts):
    """
    A font handling class for the DejaVu Sans fonts

    If a glyph is not found it will fallback to Stix Sans
    """

class StixFonts(UnicodeFonts):
    """
    A font handling class for the STIX fonts.

    In addition to what UnicodeFonts provides, this class:

    - supports "virtual fonts" which are complete alpha numeric
      character sets with different font styles at special Unicode
      code points, such as "Blackboard".

    - handles sized alternative characters for the STIXSizeX fonts.
    """

    def __init__(self, *args, **kwargs) -> None: ...
    @functools.lru_cache()
    def get_sized_alternatives_for_symbol(self, fontname, sym): ...

class StixSansFonts(StixFonts):
    """
    A font handling class for the STIX fonts (that uses sans-serif
    characters by default).
    """

SHRINK_FACTOR = ...
NUM_SIZE_LEVELS = ...

class FontConstantsBase:
    """
    A set of constants that controls how certain things, such as sub-
    and superscripts are laid out.  These are all metrics that can't
    be reliably retrieved from the font metrics in the font itself.
    """

    script_space = ...
    subdrop = ...
    sup1 = ...
    sub1 = ...
    sub2 = ...
    delta = ...
    delta_slanted = ...
    delta_integral = ...

class ComputerModernFontConstants(FontConstantsBase):
    script_space = ...
    subdrop = ...
    sup1 = ...
    sub1 = ...
    sub2 = ...
    delta = ...
    delta_slanted = ...
    delta_integral = ...

class STIXFontConstants(FontConstantsBase):
    script_space = ...
    sup1 = ...
    sub2 = ...
    delta = ...
    delta_slanted = ...
    delta_integral = ...

class STIXSansFontConstants(FontConstantsBase):
    script_space = ...
    sup1 = ...
    delta_slanted = ...
    delta_integral = ...

class DejaVuSerifFontConstants(FontConstantsBase): ...
class DejaVuSansFontConstants(FontConstantsBase): ...

class Node:
    """A node in the TeX box model."""

    def __init__(self) -> None: ...
    def __repr__(self): ...
    def get_kerning(self, next): ...
    def shrink(self):
        """
        Shrinks one level smaller.  There are only three levels of
        sizes, after which things will no longer get smaller.
        """
        ...
    def render(self, x, y):
        """Render this node."""
        ...

class Box(Node):
    """A node with a physical location."""

    def __init__(self, width, height, depth) -> None: ...
    def shrink(self): ...
    def render(self, x1, y1, x2, y2): ...

class Vbox(Box):
    """A box with only height (zero width)."""

    def __init__(self, height, depth) -> None: ...

class Hbox(Box):
    """A box with only width (zero height and depth)."""

    def __init__(self, width) -> None: ...

class Char(Node):
    """
    A single character.

    Unlike TeX, the font information and metrics are stored with each `Char`
    to make it easier to lookup the font metrics when needed.  Note that TeX
    boxes have a width, height, and depth, unlike Type1 and TrueType which use
    a full bounding box and an advance in the x-direction.  The metrics must
    be converted to the TeX model, and the advance (if different from width)
    must be converted into a `Kern` node when the `Char` is added to its parent
    `Hlist`.
    """

    def __init__(self, c, state) -> None: ...
    def __repr__(self): ...
    def is_slanted(self): ...
    def get_kerning(self, next):
        """
        Return the amount of kerning between this and the given character.

        This method is called when characters are strung together into `Hlist`
        to create `Kern` nodes.
        """
        ...
    def render(self, x, y): ...
    def shrink(self): ...

class Accent(Char):
    """
    The font metrics need to be dealt with differently for accents,
    since they are already offset correctly from the baseline in
    TrueType fonts.
    """

    def shrink(self): ...
    def render(self, x, y): ...

class List(Box):
    """A list of nodes (either horizontal or vertical)."""

    def __init__(self, elements) -> None: ...
    def __repr__(self): ...
    def shrink(self): ...

class Hlist(List):
    """A horizontal list of boxes."""

    def __init__(self, elements, w=..., m=..., do_kern=...) -> None: ...
    def kern(self):
        """
        Insert `Kern` nodes between `Char` nodes to set kerning.

        The `Char` nodes themselves determine the amount of kerning they need
        (in `~Char.get_kerning`), and this function just creates the correct
        linked list.
        """
        ...
    def hpack(self, w: float = ..., m: Literal["exactly", "additional"] = ...):
        r"""
        Compute the dimensions of the resulting boxes, and adjust the glue if
        one of those dimensions is pre-specified.  The computed sizes normally
        enclose all of the material inside the new box; but some items may
        stick out if negative glue is used, if the box is overfull, or if a
        ``\vbox`` includes other boxes that have been shifted left.

        Parameters
        ----------
        w : float, default: 0
            A width.
        m : {'exactly', 'additional'}, default: 'additional'
            Whether to produce a box whose width is 'exactly' *w*; or a box
            with the natural width of the contents, plus *w* ('additional').

        Notes
        -----
        The defaults produce a box with the natural width of the contents.
        """
        ...

class Vlist(List):
    """A vertical list of boxes."""

    def __init__(self, elements, h=..., m=...) -> None: ...
    def vpack(
        self, h: float = ..., m: Literal["exactly", "additional"] = ..., l: float = ...
    ):
        """
        Compute the dimensions of the resulting boxes, and to adjust the glue
        if one of those dimensions is pre-specified.

        Parameters
        ----------
        h : float, default: 0
            A height.
        m : {'exactly', 'additional'}, default: 'additional'
            Whether to produce a box whose height is 'exactly' *h*; or a box
            with the natural height of the contents, plus *h* ('additional').
        l : float, default: np.inf
            The maximum height.

        Notes
        -----
        The defaults produce a box with the natural height of the contents.
        """
        ...

class Rule(Box):
    """
    A solid black rectangle.

    It has *width*, *depth*, and *height* fields just as in an `Hlist`.
    However, if any of these dimensions is inf, the actual value will be
    determined by running the rule up to the boundary of the innermost
    enclosing box.  This is called a "running dimension".  The width is never
    running in an `Hlist`; the height and depth are never running in a `Vlist`.
    """

    def __init__(self, width, height, depth, state) -> None: ...
    def render(self, x, y, w, h): ...

class Hrule(Rule):
    """Convenience class to create a horizontal rule."""

    def __init__(self, state, thickness=...) -> None: ...

class Vrule(Rule):
    """Convenience class to create a vertical rule."""

    def __init__(self, state) -> None: ...

class Glue(Node):
    """
    Most of the information in this object is stored in the underlying
    ``_GlueSpec`` class, which is shared between multiple glue objects.
    (This is a memory optimization which probably doesn't matter anymore, but
    it's easier to stick to what TeX does.)
    """

    def __init__(self, glue_type) -> None: ...
    def shrink(self): ...

class HCentered(Hlist):
    """
    A convenience class to create an `Hlist` whose contents are
    centered within its enclosing box.
    """

    def __init__(self, elements) -> None: ...

class VCentered(Vlist):
    """
    A convenience class to create a `Vlist` whose contents are
    centered within its enclosing box.
    """

    def __init__(self, elements) -> None: ...

class Kern(Node):
    """
    A `Kern` node has a width field to specify a (normally
    negative) amount of spacing. This spacing correction appears in
    horizontal lists between letters like A and V when the font
    designer said that it looks better to move them closer together or
    further apart. A kern node can also appear in a vertical list,
    when its *width* denotes additional spacing in the vertical
    direction.
    """

    height = ...
    depth = ...
    def __init__(self, width) -> None: ...
    def __repr__(self): ...
    def shrink(self): ...

class AutoHeightChar(Hlist):
    """
    A character as close to the given height and depth as possible.

    When using a font with multiple height versions of some characters (such as
    the BaKoMa fonts), the correct glyph will be selected, otherwise this will
    always just return a scaled version of the glyph.
    """

    def __init__(self, c, height, depth, state, always=..., factor=...) -> None: ...

class AutoWidthChar(Hlist):
    """
    A character as close to the given width as possible.

    When using a font with multiple width versions of some characters (such as
    the BaKoMa fonts), the correct glyph will be selected, otherwise this will
    always just return a scaled version of the glyph.
    """

    def __init__(self, c, width, state, always=..., char_class=...) -> None: ...

def ship(ox, oy, box):
    """
    Ship boxes to output once they have been set up, this sends them to output.

    Since boxes can be inside of boxes inside of boxes, the main work of `ship`
    is done by two mutually recursive routines, `hlist_out` and `vlist_out`,
    which traverse the `Hlist` nodes and `Vlist` nodes inside of horizontal
    and vertical boxes.  The global variables used in TeX to store state as it
    processes have become local variables here.
    """
    ...

def Error(msg):
    """Helper class to raise parser errors."""
    ...

class ParserState:
    """
    Parser state.

    States are pushed and popped from a stack as necessary, and the "current"
    state is always at the top of the stack.

    Upon entering and leaving a group { } or math/non-math, the stack is pushed
    and popped accordingly.
    """

    def __init__(self, font_output, font, font_class, fontsize, dpi) -> None: ...
    def copy(self): ...
    @property
    def font(self): ...
    @font.setter
    def font(self, name): ...
    def get_current_underline_thickness(self):
        """Return the underline thickness for this state."""
        ...

def cmd(expr, args):
    r"""
    Helper to define TeX commands.

    ``cmd("\cmd", args)`` is equivalent to
    ``"\cmd" - (args | Error("Expected \cmd{arg}{...}"))`` where the names in
    the error message are taken from element names in *args*.  If *expr*
    already includes arguments (e.g. "\cmd{arg}{...}"), then they are stripped
    when constructing the parse element, but kept (and *expr* is used as is) in
    the error message.
    """
    ...

class Parser:
    """
    A pyparsing-based parser for strings containing math expressions.

    Raw text may also appear outside of pairs of ``$``.

    The grammar is based directly on that in TeX, though it cuts a few corners.
    """

    class _MathStyle(enum.Enum):
        DISPLAYSTYLE = ...
        TEXTSTYLE = ...
        SCRIPTSTYLE = ...
        SCRIPTSCRIPTSTYLE = ...
    def __init__(self) -> None: ...
    def parse(self, s, fonts_object, fontsize, dpi):
        """
        Parse expression *s* using the given *fonts_object* for
        output, at the given *fontsize* and *dpi*.

        Returns the parse tree of `Node` instances.
        """
        ...
    def get_state(self):
        """Get the current `State` of the parser."""
        ...
    def pop_state(self):
        """Pop a `State` off of the stack."""
        ...
    def push_state(self):
        """Push a new `State` onto the stack, copying the current state."""
        ...
    def main(self, s, loc, toks): ...
    def math_string(self, s, loc, toks): ...
    def math(self, s, loc, toks): ...
    def non_math(self, s, loc, toks): ...

    float_literal = ...

    def space(self, s, loc, toks): ...
    def customspace(self, s, loc, toks): ...
    def symbol(self, s, loc, toks): ...

    accentprefixed = ...
    def unknown_symbol(self, s, loc, toks): ...
    def accent(self, s, loc, toks): ...
    def function(self, s, loc, toks): ...
    def operatorname(self, s, loc, toks): ...
    def start_group(self, s, loc, toks): ...
    def group(self, s, loc, toks): ...
    def required_group(self, s, loc, toks): ...

    optional_group = ...
    def end_group(self, s, loc, toks): ...
    def font(self, s, loc, toks): ...
    def is_overunder(self, nucleus): ...
    def is_dropsub(self, nucleus): ...
    def is_slanted(self, nucleus): ...
    def is_between_brackets(self, s, loc): ...
    def subsuper(self, s, loc, toks): ...
    def style_literal(self, s, loc, toks): ...
    def genfrac(self, s, loc, toks): ...
    def frac(self, s, loc, toks): ...
    def dfrac(self, s, loc, toks): ...
    def binom(self, s, loc, toks): ...

    overset = ...
    def sqrt(self, s, loc, toks): ...
    def overline(self, s, loc, toks): ...
    def auto_delim(self, s, loc, toks): ...
