import datetime
import numpy as np
from typing import Any, Callable, Iterable, Literal, Sequence
from matplotlib._typing import *
from matplotlib.transforms import Transform
from matplotlib.backend_bases import MouseButton
from matplotlib.ticker import Formatter
from matplotlib.axes import Axes

"""
This type stub file was generated by pyright.
"""

from matplotlib.axes import Axes
from matplotlib.ticker import Formatter
from matplotlib.transforms import Transform

"""
This type stub file was generated by pyright.
"""

class GeoAxes(Axes):
    """An abstract base class for geographic projections."""

    class ThetaFormatter(Formatter):
        """
        Used to format the theta tick labels.  Converts the native
        unit of radians into degrees and adds a degree symbol.
        """

        def __init__(self, round_to=...) -> None: ...
        def __call__(self, x, pos=...): ...

    RESOLUTION = ...
    def clear(self): ...
    def get_xaxis_transform(self, which=...): ...
    def get_xaxis_text1_transform(self, pad): ...
    def get_xaxis_text2_transform(self, pad): ...
    def get_yaxis_transform(self, which=...): ...
    def get_yaxis_text1_transform(self, pad): ...
    def get_yaxis_text2_transform(self, pad): ...
    def set_yscale(self, *args, **kwargs): ...

    set_xscale = ...
    def set_xlim(self, *args, **kwargs):
        """Not supported. Please consider using Cartopy."""
        ...
    set_ylim = ...
    def format_coord(self, lon, lat):
        """Return a format string formatting the coordinate."""
        ...
    def set_longitude_grid(self, degrees):
        """
        Set the number of degrees between each longitude grid.
        """
        ...
    def set_latitude_grid(self, degrees):
        """
        Set the number of degrees between each latitude grid.
        """
        ...
    def set_longitude_grid_ends(self, degrees):
        """
        Set the latitude(s) at which to stop drawing the longitude grids.
        """
        ...
    def get_data_ratio(self):
        """Return the aspect ratio of the data itself."""
        ...
    def can_zoom(self):
        """
        Return whether this axes supports the zoom box button functionality.

        This axes object does not support interactive zoom box.
        """
        ...
    def can_pan(self):
        """
        Return whether this axes supports the pan/zoom button functionality.

        This axes object does not support interactive pan/zoom.
        """
        ...
    def start_pan(self, x: float, y: float, button: MouseButton): ...
    def end_pan(self): ...
    def drag_pan(self, button: MouseButton, key: str | None, x: float, y: float): ...

class _GeoTransform(Transform):
    input_dims = ...
    def __init__(self, resolution) -> None:
        """
        Create a new geographical transform.

        Resolution is the number of steps to interpolate between each input
        line segment to approximate its path in curved space.
        """
        ...
    def __str__(self) -> str: ...
    def transform_path_non_affine(self, path): ...

class AitoffAxes(GeoAxes):
    name = ...

    class AitoffTransform(_GeoTransform):
        """The base Aitoff transform."""

        def transform_non_affine(self, ll): ...
        def inverted(self): ...

    class InvertedAitoffTransform(_GeoTransform):
        def transform_non_affine(self, xy): ...
        def inverted(self): ...

    def __init__(self, *args, **kwargs) -> None: ...

class HammerAxes(GeoAxes):
    name = ...

    class HammerTransform(_GeoTransform):
        """The base Hammer transform."""

        def transform_non_affine(self, ll): ...
        def inverted(self): ...

    class InvertedHammerTransform(_GeoTransform):
        def transform_non_affine(self, xy): ...
        def inverted(self): ...

    def __init__(self, *args, **kwargs) -> None: ...

class MollweideAxes(GeoAxes):
    name = ...

    class MollweideTransform(_GeoTransform):
        """The base Mollweide transform."""

        def transform_non_affine(self, ll): ...
        def inverted(self): ...

    class InvertedMollweideTransform(_GeoTransform):
        def transform_non_affine(self, xy): ...
        def inverted(self): ...

    def __init__(self, *args, **kwargs) -> None: ...

class LambertAxes(GeoAxes):
    name = ...

    class LambertTransform(_GeoTransform):
        """The base Lambert transform."""

        def __init__(self, center_longitude, center_latitude, resolution) -> None:
            """
            Create a new Lambert transform.  Resolution is the number of steps
            to interpolate between each input line segment to approximate its
            path in curved Lambert space.
            """
            ...
        def transform_non_affine(self, ll): ...
        def inverted(self): ...

    class InvertedLambertTransform(_GeoTransform):
        def __init__(self, center_longitude, center_latitude, resolution) -> None: ...
        def transform_non_affine(self, xy): ...
        def inverted(self): ...

    def __init__(
        self, *args, center_longitude=..., center_latitude=..., **kwargs
    ) -> None: ...
    def clear(self): ...
