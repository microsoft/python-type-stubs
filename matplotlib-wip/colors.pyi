from .scale import AsinhScale, FuncScale, LogScale, SymmetricalLogScale
import numpy as np
from typing import Callable, Literal
from matplotlib._typing import *

import functools
from collections.abc import Mapping

class _ColorMapping(dict):
    def __init__(self, mapping) -> None: ...
    def __setitem__(self, key, value): ...
    def __delitem__(self, key): ...

def get_named_colors_mapping(): ...

class ColorSequenceRegistry(Mapping):
    def __init__(self) -> None: ...
    def __getitem__(self, item): ...
    def __iter__(self): ...
    def __len__(self): ...
    def __str__(self) -> str: ...
    def register(self, name: str, color_list: list[Color]): ...
    def unregister(self, name): ...

def is_color_like(c): ...
def same_color(c1, c2): ...
def to_rgba(c: np.ma.masked_array, alpha: float = ...) -> tuple: ...
def to_rgba_array(c: ArrayLike, alpha: float = ...) -> list: ...
def to_rgb(c): ...
def to_hex(c: np.ma.masked_array, keep_alpha: bool = ...) -> str: ...

cnames = ...
hexColorPattern = ...
rgb2hex = ...
hex2color = ...

class ColorConverter:

    colors = ...
    cache = ...
    to_rgb = ...
    to_rgba = ...
    to_rgba_array = ...

colorConverter = ...

class Colormap:
    def __init__(self, name, N=...) -> None: ...
    def __call__(
        self,
        X: float | int | np.ndarray | Scalar,
        alpha: float | ArrayLike | None = ...,
        bytes: bool = ...,
    ) -> tuple: ...
    def __copy__(self): ...
    def __eq__(self, other) -> bool: ...
    def get_bad(self): ...
    def set_bad(self, color=..., alpha=...): ...
    def get_under(self): ...
    def set_under(self, color=..., alpha=...): ...
    def get_over(self): ...
    def set_over(self, color=..., alpha=...): ...
    def set_extremes(self, *, bad=..., under=..., over=...): ...
    def with_extremes(self, *, bad=..., under=..., over=...): ...
    def is_gray(self): ...
    def reversed(self, name: str = ...): ...
    def copy(self): ...

class LinearSegmentedColormap(Colormap):
    def __init__(self, name, segmentdata, N=..., gamma=...) -> None: ...
    def set_gamma(self, gamma): ...
    @staticmethod
    def from_list(name: str, colors, N: int = ..., gamma: float = ...): ...
    def reversed(self, name: str = ...) -> LinearSegmentedColormap: ...

class ListedColormap(Colormap):
    def __init__(self, colors: list, array, name: str = ..., N: int = ...) -> None: ...
    def reversed(self, name: str = ...) -> ListedColormap: ...

class Normalize:
    def __init__(self, vmin=..., vmax=..., clip=...) -> None: ...
    @property
    def vmin(self): ...
    @vmin.setter
    def vmin(self, value): ...
    @property
    def vmax(self): ...
    @vmax.setter
    def vmax(self, value): ...
    @property
    def clip(self): ...
    @clip.setter
    def clip(self, value): ...
    @staticmethod
    def process_value(value): ...
    def __call__(self, value, clip: bool = ...): ...
    def inverse(self, value): ...
    def autoscale(self, A): ...
    def autoscale_None(self, A): ...
    def scaled(self): ...

class TwoSlopeNorm(Normalize):
    def __init__(self, vcenter, vmin=..., vmax=...) -> None: ...
    @property
    def vcenter(self): ...
    @vcenter.setter
    def vcenter(self, value): ...
    def autoscale_None(self, A): ...
    def __call__(self, value, clip=...): ...
    def inverse(self, value): ...

class CenteredNorm(Normalize):
    def __init__(self, vcenter=..., halfrange=..., clip=...) -> None: ...
    def autoscale(self, A): ...
    def autoscale_None(self, A): ...
    @property
    def vcenter(self): ...
    @vcenter.setter
    def vcenter(self, vcenter): ...
    @property
    def halfrange(self): ...
    @halfrange.setter
    def halfrange(self, halfrange): ...
    def __call__(self, value, clip: bool = ...): ...

def make_norm_from_scale(scale_cls, base_norm_cls=..., *, init=...): ...
@make_norm_from_scale(
    FuncScale, init=lambda functions, vmin=None, vmax=None, clip=False: None
)
class FuncNorm(Normalize): ...

@make_norm_from_scale(functools.partial(LogScale, nonpositive="mask"))
class LogNorm(Normalize): ...

@make_norm_from_scale(
    SymmetricalLogScale,
    init=lambda linthresh, linscale=1, vmin=None, vmax=None, clip=False, *, base=10: None,
)
class SymLogNorm(Normalize):
    @property
    def linthresh(self): ...
    @linthresh.setter
    def linthresh(self, value): ...

@make_norm_from_scale(
    AsinhScale, init=lambda linear_width=1, vmin=None, vmax=None, clip=False: None
)
class AsinhNorm(Normalize):
    @property
    def linear_width(self): ...
    @linear_width.setter
    def linear_width(self, value): ...

class PowerNorm(Normalize):
    def __init__(self, gamma, vmin=..., vmax=..., clip=...) -> None: ...
    def __call__(self, value, clip: bool = ...): ...
    def inverse(self, value): ...

class BoundaryNorm(Normalize):
    def __init__(self, boundaries, ncolors, clip=..., *, extend=...) -> None: ...
    def __call__(self, value, clip=...): ...
    def inverse(self, value): ...

class NoNorm(Normalize):
    def __call__(self, value, clip: bool = ...): ...
    def inverse(self, value): ...

def rgb_to_hsv(arr): ...
def hsv_to_rgb(hsv): ...

class LightSource:
    def __init__(
        self,
        azdeg=...,
        altdeg=...,
        hsv_min_val=...,
        hsv_max_val=...,
        hsv_min_sat=...,
        hsv_max_sat=...,
    ) -> None: ...
    @property
    def direction(self): ...
    def hillshade(
        self,
        elevation,
        vert_exag: float = ...,
        dx: float = ...,
        dy: float = ...,
        fraction: float = ...,
    ) -> np.ndarray: ...
    def shade_normals(self, normals, fraction: float = ...) -> np.ndarray: ...
    def shade(
        self,
        data,
        cmap: Colormap,
        norm=...,
        blend_mode: Literal["hsv", "overlay", "soft"] | Callable = ...,
        vmin: float | None = ...,
        vmax: float | None = ...,
        vert_exag: float = ...,
        dx: float = ...,
        dy: float = ...,
        fraction: float = ...,
        **kwargs
    ) -> np.ndarray: ...
    def shade_rgb(
        self,
        rgb: ArrayLike,
        elevation: ArrayLike,
        fraction: float = ...,
        blend_mode: Literal["hsv", "overlay", "soft"] | Callable = ...,
        vert_exag: float = ...,
        dx: float = ...,
        dy: float = ...,
        **kwargs
    ) -> np.ndarray: ...
    def blend_hsv(
        self,
        rgb: np.ndarray,
        intensity: np.ndarray,
        hsv_max_sat: float = ...,
        hsv_max_val: float = ...,
        hsv_min_val: float = ...,
        hsv_min_sat: float = ...,
    ) -> np.ndarray: ...
    def blend_soft_light(
        self, rgb: np.ndarray, intensity: np.ndarray
    ) -> np.ndarray: ...
    def blend_overlay(self, rgb: np.ndarray, intensity: np.ndarray) -> np.ndarray: ...

def from_levels_and_colors(
    levels, colors, extend: Literal["neither", "min", "max", "both"] = ...
): ...
