import datetime
import numpy as np
from typing import Any, Callable, Iterable, Literal, Sequence
from matplotlib._typing import *
from matplotlib.backend_bases import ToolContainerBase
from matplotlib.backend_bases import FigureCanvasBase
from matplotlib.figure import Figure
from matplotlib.backend_bases import _Backend

"""
This type stub file was generated by pyright.
"""

import tkinter as tk
from matplotlib import _api, backend_tools
from matplotlib.backend_bases import (
    FigureCanvasBase,
    FigureManagerBase,
    NavigationToolbar2,
    TimerBase,
    ToolContainerBase,
    _Backend,
)

"""
This type stub file was generated by pyright.
"""

backend_version = ...
cursord = ...

TK_PHOTO_COMPOSITE_OVERLAY = ...
TK_PHOTO_COMPOSITE_SET = ...

def blit(photoimage, aggimage, offsets, bbox=...):
    """
    Blit *aggimage* to *photoimage*.

    *offsets* is a tuple describing how to fill the ``offset`` field of the
    ``Tk_PhotoImageBlock`` struct: it should be (0, 1, 2, 3) for RGBA8888 data,
    (2, 1, 0, 3) for little-endian ARBG32 (i.e. GBRA8888) data and (1, 2, 3, 0)
    for big-endian ARGB32 (i.e. ARGB8888) data.

    If *bbox* is passed, it defines the region that gets blitted. That region
    will be composed with the previous data according to the alpha channel.
    Blitting will be clipped to pixels inside the canvas, including silently
    doing nothing if the *bbox* region is entirely outside the canvas.

    Tcl events must be dispatched to trigger a blit from a non-Tcl thread.
    """
    ...

class TimerTk(TimerBase):
    """Subclass of `backend_bases.TimerBase` using Tk timer events."""

    def __init__(self, parent, *args, **kwargs) -> None: ...

class FigureCanvasTk(FigureCanvasBase):
    required_interactive_framework = ...
    manager_class = ...
    def __init__(self, figure=..., master=...) -> None: ...
    def resize(self, event): ...
    def draw_idle(self): ...
    def get_tk_widget(self):
        """
        Return the Tk widget used to implement FigureCanvasTkAgg.

        Although the initial implementation uses a Tk canvas,  this routine
        is intended to hide that fact.
        """
        ...
    def motion_notify_event(self, event): ...
    def enter_notify_event(self, event): ...
    def button_press_event(self, event, dblclick=...): ...
    def button_dblclick_event(self, event): ...
    def button_release_event(self, event): ...
    def scroll_event(self, event): ...
    def scroll_event_windows(self, event):
        """MouseWheel event processor"""
        ...
    def key_press(self, event): ...
    def key_release(self, event): ...
    def new_timer(self, *args, **kwargs): ...
    def flush_events(self): ...
    def start_event_loop(self, timeout=...): ...
    def stop_event_loop(self): ...
    def set_cursor(self, cursor): ...

class FigureManagerTk(FigureManagerBase):
    """
    Attributes
    ----------
    canvas : `FigureCanvas`
        The FigureCanvas instance
    num : int or str
        The Figure number
    toolbar : tk.Toolbar
        The tk.Toolbar
    window : tk.Window
        The tk.Window
    """

    def __init__(self, canvas, num, window) -> None: ...
    @classmethod
    def create_with_canvas(cls, canvas_class, figure, num): ...
    def resize(self, width, height): ...
    def show(self): ...
    def destroy(self, *args): ...
    def get_window_title(self): ...
    def set_window_title(self, title): ...
    def full_screen_toggle(self): ...

class NavigationToolbar2Tk(NavigationToolbar2, tk.Frame):
    window = ...
    def __init__(self, canvas, window=..., *, pack_toolbar=...) -> None:
        """
        Parameters
        ----------
        canvas : `FigureCanvas`
            The figure canvas on which to operate.
        window : tk.Window
            The tk.Window which owns this toolbar.
        pack_toolbar : bool, default: True
            If True, add the toolbar to the parent's pack manager's packing
            list during initialization with ``side="bottom"`` and ``fill="x"``.
            If you want to use the toolbar with a different layout manager, use
            ``pack_toolbar=False``.
        """
        ...
    def pan(self, *args): ...
    def zoom(self, *args): ...
    def set_message(self, s): ...
    def draw_rubberband(self, event, x0, y0, x1, y1): ...
    def remove_rubberband(self): ...

    lastrect = ...
    def save_figure(self, *args): ...
    def set_history_buttons(self): ...

class ToolTip:
    """
    Tooltip recipe from
    http://www.voidspace.org.uk/python/weblog/arch_d7_2006_07_01.shtml#e387
    """

    @staticmethod
    def createToolTip(widget, text): ...
    def __init__(self, widget) -> None: ...
    def showtip(self, text):
        """Display text in tooltip window."""
        ...
    def hidetip(self): ...

class RubberbandTk(backend_tools.RubberbandBase):
    def draw_rubberband(self, x0, y0, x1, y1): ...
    def remove_rubberband(self): ...

    lastrect = ...

class SetCursorTk(backend_tools.SetCursorBase):
    def set_cursor(self, cursor): ...

class ToolbarTk(ToolContainerBase, tk.Frame):
    def __init__(self, toolmanager, window=...) -> None: ...
    def add_toolitem(self, name, group, position, image_file, description, toggle): ...
    def toggle_toolitem(self, name, toggled): ...
    def remove_toolitem(self, name): ...
    def set_message(self, s): ...

class SaveFigureTk(backend_tools.SaveFigureBase):
    def trigger(self, *args): ...

class ConfigureSubplotsTk(backend_tools.ConfigureSubplotsBase):
    def trigger(self, *args): ...

class HelpTk(backend_tools.ToolHelpBase):
    def trigger(self, *args): ...

Toolbar = ToolbarTk

class _BackendTk(_Backend):
    FigureManager = FigureManagerTk
    @staticmethod
    def mainloop(): ...
