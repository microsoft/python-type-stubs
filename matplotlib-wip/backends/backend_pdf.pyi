import datetime
import numpy as np
from typing import Any, Callable, Iterable, Literal, Sequence
from matplotlib._typing import *
from matplotlib.transforms import Transform
from matplotlib.text import Text
from matplotlib.path import Path
from matplotlib._enums import JoinStyle
from matplotlib.backend_bases import GraphicsContextBase
from matplotlib.font_manager import FontProperties
from matplotlib.backend_bases import FigureCanvasBase
from matplotlib.figure import Figure
from matplotlib._enums import CapStyle
from matplotlib.backend_bases import _Backend
from matplotlib.transforms import Affine2DBase
from matplotlib.transforms import Affine2D

"""
This type stub file was generated by pyright.
"""
from io import BytesIO
from matplotlib._enums import CapStyle, JoinStyle
from matplotlib.font_manager import FontProperties
from typing import Any, Dict, List, Optional, Set, Tuple, Union

from enum import Enum
from functools import total_ordering
from matplotlib import _api
from matplotlib.backend_bases import (
    FigureCanvasBase,
    FigureManagerBase,
    GraphicsContextBase,
    _Backend,
)
from . import _backend_pdf_ps

"""
A PDF Matplotlib backend.

Author: Jouni K Sepp√§nen <jks@iki.fi> and others.
"""

def fill(strings, linelen=...): ...
def pdfRepr(obj: Any) -> bytes:  # -> bytes:
    """Map Python objects to PDF syntax."""
    ...

class Reference:
    """
    PDF reference object.

    Use PdfFile.reserveObject() to create References.
    """

    def __init__(self, id: int) -> None: ...
    def __repr__(self): ...
    def pdfRepr(self) -> bytes: ...
    def write(self, contents: Any, file: "PdfFile") -> None: ...

@total_ordering
class Name:
    """PDF name object."""

    def __init__(self, name: Union[bytes, Name, str]) -> None: ...
    def __repr__(self): ...
    def __str__(self) -> str: ...
    def __eq__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    @staticmethod
    def hexify(match): ...
    def pdfRepr(self) -> bytes: ...

class Operator:
    def __init__(self, op) -> None: ...
    def __repr__(self): ...
    def pdfRepr(self): ...

class Verbatim:
    """Store verbatim PDF command content for later inclusion in the stream."""

    def __init__(self, x: bytes) -> None: ...
    def pdfRepr(self) -> bytes: ...

class Op(Enum):
    """PDF operators (not an exhaustive list)."""

    close_fill_stroke = ...
    fill_stroke = ...
    fill = ...
    closepath = ...
    close_stroke = ...
    stroke = ...
    endpath = ...
    begin_text = ...
    end_text = ...
    curveto = ...
    rectangle = ...
    lineto = ...
    moveto = ...
    concat_matrix = ...
    use_xobject = ...
    setgray_stroke = ...
    setgray_nonstroke = ...
    setrgb_stroke = ...
    setrgb_nonstroke = ...
    setcolorspace_stroke = ...
    setcolorspace_nonstroke = ...
    setcolor_stroke = ...
    setcolor_nonstroke = ...
    setdash = ...
    setlinejoin = ...
    setlinecap = ...
    setgstate = ...
    gsave = ...
    grestore = ...
    textpos = ...
    selectfont = ...
    textmatrix = ...
    show = ...
    showkern = ...
    setlinewidth = ...
    clip = ...
    shading = ...
    op = ...
    def pdfRepr(self) -> bytes: ...
    @classmethod
    def paint_path(
        cls, fill: bool, stroke: bool
    ) -> "Op":  # -> Literal[Op.fill_stroke, Op.stroke, Op.fill, Op.endpath]:
        """
        Return the PDF operator to paint a path.

        Parameters
        ----------
        fill : bool
            Fill the path with the fill color.
        stroke : bool
            Stroke the outline of the path with the line color.
        """
        ...

class Stream:
    """
    PDF stream object.

    This has no pdfRepr method. Instead, call begin(), then output the
    contents of the stream by calling write(), and finally call end().
    """

    def __init__(
        self,
        id: int,
        len: Optional[Reference],
        file: "PdfFile",
        extra: Optional[
            Union[
                Dict[str, Union[int, Name]],
                Dict[str, Union[Name, list[int]]],
                Dict[str, Union[Name, int, Verbatim]],
                Dict[str, Union[Name, int, Verbatim, Reference]],
            ]
        ] = ...,
        png: Optional[Dict[str, int]] = ...,
    ) -> None:
        """
        Parameters
        ----------
        id : int
            Object id of the stream.
        len : Reference or None
            An unused Reference object for the length of the stream;
            None means to use a memory buffer so the length can be inlined.
        file : PdfFile
            The underlying object to write the stream to.
        extra : dict from Name to anything, or None
            Extra key-value pairs to include in the stream header.
        png : dict or None
            If the data is already png encoded, the decode parameters.
        """
        ...
    def end(self) -> None:  # -> None:
        """Finalize stream."""
        ...
    def write(self, data: bytes) -> None:  # -> None:
        """Write some data on the stream."""
        ...

class PdfFile:
    """PDF file object."""

    def __init__(self, filename: Union[BytesIO, str], metadata: None = ...) -> None:
        """
        Parameters
        ----------
        filename : str or path-like or file-like
            Output target; if a string, a file will be opened for writing.

        metadata : dict from strings to strings and dates
            Information dictionary object (see PDF reference section 10.2.1
            'Document Information Dictionary'), e.g.:
            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.

            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',
            'Creator', 'Producer', 'CreationDate', 'ModDate', and
            'Trapped'. Values have been predefined for 'Creator', 'Producer'
            and 'CreationDate'. They can be removed by setting them to `None`.
        """
        ...
    def newPage(self, width, height): ...
    def newTextnote(self, text: str, positionRect: list[int] = ...) -> None: ...
    def finalize(self) -> None:  # -> None:
        """Write out the various deferred objects and the pdf end matter."""
        ...
    def close(self) -> None:  # -> None:
        """Flush all buffers and free all resources."""
        ...
    def write(self, data: bytes) -> None: ...
    def output(self, *data) -> None: ...
    def beginStream(
        self,
        id: int,
        len: Optional[Reference],
        extra: Optional[
            Union[
                Dict[str, Union[int, Name]],
                Dict[str, Union[Name, list[int]]],
                Dict[str, Union[Name, int, Verbatim]],
                Dict[str, Union[Name, int, Verbatim, Reference]],
            ]
        ] = ...,
        png: Optional[Dict[str, int]] = ...,
    ) -> None: ...
    def endStream(self) -> None: ...
    def outputStream(self, ref: Reference, data: bytes, *, extra=...) -> None: ...
    def fontName(self, fontprop: Union[FontProperties, str]) -> Name:  # -> Name:
        """
        Select a font based on fontprop and return a name suitable for
        Op.selectfont. If fontprop is a string, it will be interpreted
        as the filename of the font.
        """
        ...
    def dviFontName(self, dvifont):  # -> Name:
        """
        Given a dvi font object, return a name suitable for Op.selectfont.
        This registers the font information in ``self.dviFontInfo`` if not yet
        registered.
        """
        ...
    def writeFonts(self) -> None: ...
    def createType1Descriptor(self, t1font, fontfile): ...
    def embedTTF(self, filename: str, characters: Set[int]) -> Reference:
        """Embed the TTF font from the named file into the document."""
        ...
    def alphaState(self, alpha: Tuple[float, float]) -> Name:  # -> Name:
        """Return name of an ExtGState that sets alpha to the given value."""
        ...
    def writeExtGSTates(self) -> None: ...
    def hatchPattern(self, hatch_style): ...
    def writeHatches(self) -> None: ...
    def addGouraudTriangles(
        self, points: np.ndarray, colors: np.ndarray
    ) -> tuple[Name, Reference]:
        """
        Add a Gouraud triangle shading.

        Parameters
        ----------
        points : np.ndarray
            Triangle vertices, shape (n, 3, 2)
            where n = number of triangles, 3 = vertices, 2 = x, y.
        colors : np.ndarray
            Vertex colors, shape (n, 3, 1) or (n, 3, 4)
            as with points, but last dimension is either (gray,)
            or (r, g, b, alpha).

        Returns
        -------
        Name, Reference
        """
        ...
    def writeGouraudTriangles(self) -> None: ...
    def imageObject(self, image):  # -> Name:
        """Return name of an image XObject representing the given image."""
        ...
    def writeImages(self) -> None: ...
    def markerObject(
        self, path, trans, fill, stroke, lw, joinstyle, capstyle
    ):  # -> Name:
        """Return name of a marker XObject representing the given path."""
        ...
    def writeMarkers(self) -> None: ...
    def pathCollectionObject(self, gc, path, trans, padding, filled, stroked): ...
    def writePathCollectionTemplates(self) -> None: ...
    @staticmethod
    def pathOperations(path, transform, clip=..., simplify=..., sketch=...): ...
    def writePath(self, path, transform, clip=..., sketch=...): ...
    def reserveObject(self, name: str = ...) -> Reference:  # -> Reference:
        """
        Reserve an ID for an indirect object.

        The name is used for debugging in case we forget to print out
        the object with writeObject.
        """
        ...
    def recordXref(self, id: int) -> None: ...
    def writeObject(self, object: Reference, contents: Any) -> None: ...
    def writeXref(self) -> None:  # -> None:
        """Write out the xref table."""
        ...
    def writeInfoDict(self) -> None:  # -> None:
        """Write out the info dictionary, checking it for good form"""
        ...
    def writeTrailer(self) -> None:  # -> None:
        """Write out the PDF trailer."""
        ...

class RendererPdf(_backend_pdf_ps.RendererPDFPSBase):
    def __init__(self, file, image_dpi, height, width) -> None: ...
    def finalize(self) -> None: ...
    def check_gc(
        self,
        gc: "GraphicsContextPdf",
        fillcolor: Optional[
            Union[Tuple[float, float, float, float], Tuple[float, float, float, int]]
        ] = ...,
    ) -> None: ...
    def get_image_magnification(self): ...
    def draw_image(
        self,
        gc: GraphicsContextBase,
        x: Scalar,
        y: Scalar,
        im,
        transform: Affine2DBase = ...,
    ): ...
    def draw_path(self, gc, path, transform, rgbFace=...): ...
    def draw_path_collection(
        self,
        gc,
        master_transform,
        paths,
        all_transforms,
        offsets,
        offsetTrans,
        facecolors,
        edgecolors,
        linewidths,
        linestyles,
        antialiaseds,
        urls,
        offset_position,
    ): ...
    def draw_markers(
        self,
        gc: GraphicsContextBase,
        marker_path,
        marker_trans: Transform,
        path,
        trans: Transform,
        rgbFace=...,
    ): ...
    def draw_gouraud_triangle(self, gc: GraphicsContextBase, points, colors, trans): ...
    def draw_gouraud_triangles(self, gc, points, colors, trans): ...
    def draw_mathtext(self, gc, x, y, s, prop, angle): ...
    def draw_tex(self, gc, x, y, s, prop, angle, *, mtext=...): ...
    def encode_string(self, s: str, fonttype: int) -> bytes: ...
    def draw_text(
        self,
        gc: GraphicsContextBase,
        x: float,
        y: float,
        s: str,
        prop: FontProperties,
        angle: float,
        ismath=...,
        mtext: Text = ...,
    ): ...
    def new_gc(self) -> "GraphicsContextPdf": ...

class GraphicsContextPdf(GraphicsContextBase):
    def __init__(self, file: PdfFile) -> None: ...
    def __repr__(self): ...
    def stroke(self) -> bool:  # -> Literal[True]:
        """
        Predicate: does the path need to be stroked (its outline drawn)?
        This tests for the various conditions that disable stroking
        the path, in which case it would presumably be filled.
        """
        ...
    def fill(self, *args) -> bool:  # -> Any | bool:
        """
        Predicate: does the path need to be filled?

        An optional argument can be used to specify an alternative
        _fillcolor, as needed by RendererPdf.draw_markers.
        """
        ...
    def paint(
        self,
    ) -> Op:  # -> Literal[Op.fill_stroke, Op.stroke, Op.fill, Op.endpath]:
        """
        Return the appropriate pdf operator to cause the path to be
        stroked, filled, or both.
        """
        ...
    capstyles = ...
    joinstyles = ...
    def capstyle_cmd(self, style: CapStyle) -> list[Union[int, Op]]: ...
    def joinstyle_cmd(self, style: JoinStyle) -> list[Union[int, Op]]: ...
    def linewidth_cmd(
        self, width: Union[int, float]
    ) -> list[Union[float, Op, int]]: ...
    def dash_cmd(self, dashes): ...
    def alpha_cmd(
        self, alpha: float, forced: bool, effective_alphas: Tuple[float, float]
    ) -> list[Union[Name, Op]]: ...
    def hatch_cmd(
        self, hatch: None, hatch_color: Tuple[float, float, float, float]
    ) -> list[Union[Name, Op, float]]: ...
    def rgb_cmd(
        self,
        rgb: Union[Tuple[float, float, float, float], Tuple[float, float, float, int]],
    ) -> list[Union[float, Op]]: ...
    def fillcolor_cmd(
        self,
        rgb: Optional[
            Union[Tuple[float, float, float, float], Tuple[float, float, float, int]]
        ],
    ) -> list[Union[Any, float, Op]]: ...
    def push(self) -> list[Op]: ...
    def pop(self) -> list[Op]: ...
    def clip_cmd(self, cliprect: None, clippath: None) -> list[Op]:  # -> list[Unknown]:
        """Set clip rectangle. Calls `.pop()` and `.push()`."""
        ...
    commands = ...
    def delta(
        self, other: "GraphicsContextPdf"
    ) -> list[Union[Op, Name, float, int, Any]]:
        """
        Copy properties of other into self and return PDF commands
        needed to transform self into other.
        """
        ...
    def copy_properties(self, other: "GraphicsContextPdf") -> None:  # -> None:
        """
        Copy properties of other into self.
        """
        ...
    def finalize(self) -> list[Op]:  # -> list[Unknown]:
        """
        Make sure every pushed graphics state is popped.
        """
        ...

class PdfPages:
    """
    A multi-page PDF file.

    Examples
    --------
    >>> import matplotlib.pyplot as plt
    >>> # Initialize:
    >>> with PdfPages('foo.pdf') as pdf:
    ...     # As many times as you like, create a figure fig and save it:
    ...     fig = plt.figure()
    ...     pdf.savefig(fig)
    ...     # When no figure is specified the current figure is saved
    ...     pdf.savefig()

    Notes
    -----
    In reality `PdfPages` is a thin wrapper around `PdfFile`, in order to avoid
    confusion when using `~.pyplot.savefig` and forgetting the format argument.
    """

    def __init__(
        self, filename: str, keep_empty: bool = ..., metadata: None = ...
    ) -> None:
        """
        Create a new PdfPages object.

        Parameters
        ----------
        filename : str or path-like or file-like
            Plots using `PdfPages.savefig` will be written to a file at this
            location. The file is opened at once and any older file with the
            same name is overwritten.

        keep_empty : bool, optional
            If set to False, then empty pdf files will be deleted automatically
            when closed.

        metadata : dict, optional
            Information dictionary object (see PDF reference section 10.2.1
            'Document Information Dictionary'), e.g.:
            ``{'Creator': 'My software', 'Author': 'Me', 'Title': 'Awesome'}``.

            The standard keys are 'Title', 'Author', 'Subject', 'Keywords',
            'Creator', 'Producer', 'CreationDate', 'ModDate', and
            'Trapped'. Values have been predefined for 'Creator', 'Producer'
            and 'CreationDate'. They can be removed by setting them to `None`.
        """
        ...
    def __enter__(self) -> "PdfPages": ...
    def __exit__(self, exc_type, exc_val, exc_tb): ...
    def close(self) -> None:  # -> None:
        """
        Finalize this object, making the underlying file a complete
        PDF file.
        """
        ...
    def infodict(self):  # -> dict[str | Any, Unknown]:
        """
        Return a modifiable information dictionary object
        (see PDF reference section 10.2.1 'Document Information
        Dictionary').
        """
        ...
    def savefig(self, figure: None = ..., **kwargs) -> None:  # -> None:
        """
        Save a `.Figure` to this file as a new page.

        Any other keyword arguments are passed to `~.Figure.savefig`.

        Parameters
        ----------
        figure : `.Figure` or int, default: the active figure
            The figure, or index of the figure, that is saved to the file.
        """
        ...
    def get_pagecount(self) -> int:  # -> int:
        """Return the current number of pages in the multipage pdf file."""
        ...
    def attach_note(self, text: str, positionRect: list[int] = ...) -> None:  # -> None:
        """
        Add a new text note to the page to be saved next. The optional
        positionRect specifies the position of the new note on the
        page. It is outside the page per default to make sure it is
        invisible on printouts.
        """
        ...

class FigureCanvasPdf(FigureCanvasBase):
    fixed_dpi = ...
    filetypes = ...
    def get_default_filetype(self): ...
    def print_pdf(
        self,
        filename: Union[BytesIO, PdfPages, str],
        *,
        bbox_inches_restore=...,
        metadata=...
    ) -> None: ...
    def draw(self): ...

FigureManagerPdf = FigureManagerBase

class _BackendPdf(_Backend):
    FigureCanvas = FigureCanvasPdf
