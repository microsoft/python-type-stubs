from ._typing import *
from typing import Callable

class NonIntersectingPathException(ValueError): ...

def get_intersection(cx1, cy1, cos_t1, sin_t1, cx2, cy2, cos_t2, sin_t2): ...
def get_normal_points(cx, cy, cos_t, sin_t, length): ...
def split_de_casteljau(beta, t): ...
def find_bezier_t_intersecting_with_closedpath(
    bezier_point_at_t: Callable,
    inside_closedpath: Callable,
    t0: float = ...,
    t1: float = ...,
    tolerance: float = ...,
) -> tuple[float, float]: ...

class BezierSegment:
    def __init__(self, control_points) -> None: ...
    def __call__(self, t: ArrayLike) -> tuple: ...
    def point_at_t(self, t) -> tuple[float]: ...
    @property
    def control_points(self): ...
    @property
    def dimension(self): ...
    @property
    def degree(self) -> int: ...
    @property
    def polynomial_coefficients(self): ...
    def axis_aligned_extrema(self) -> tuple: ...

def split_bezier_intersecting_with_closedpath(
    bezier, inside_closedpath: Callable, tolerance: float = ...
) -> list: ...
def split_path_inout(path, inside, tolerance=..., reorder_inout=...): ...
def inside_circle(cx, cy, r) -> Callable: ...
def get_cos_sin(x0, y0, x1, y1): ...
def check_if_parallel(
    dx1: float, dy1: float, dx2: float, dy2: float, tolerance: float = ...
) -> bool: ...
def get_parallels(bezier2, width): ...
def find_control_points(c1x, c1y, mmx, mmy, c2x, c2y): ...
def make_wedged_bezier2(bezier2, width, w1=..., wm=..., w2=...): ...
