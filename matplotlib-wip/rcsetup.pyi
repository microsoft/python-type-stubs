import datetime
import numpy as np
from typing import Any, Callable, Iterable, Literal, Sequence
from matplotlib._typing import *
from matplotlib.lines import Line2D
from matplotlib.artist import Artist

"""
This type stub file was generated by pyright.
"""
from cycler import Cycler
from typing import List, Optional, Tuple, Union

import ast

"""
This type stub file was generated by pyright.
"""
interactive_bk = ...
non_interactive_bk = ...
all_backends = ...

class ValidateInStrings:
    def __init__(
        self,
        key: str,
        valid: Union[list[str], _ignorecase],
        ignorecase: bool = ...,
        *,
        _deprecated_since=...
    ) -> None:
        """*valid* is a list of legal strings."""
        ...
    def __call__(self, s: str) -> str: ...

def validate_any(s): ...

validate_anylist = ...

def validate_bool(b: Union[bool, str]) -> bool:
    """Convert b to ``bool`` or raise."""
    ...

def validate_axisbelow(s: Union[bool, str]) -> Union[bool, str]: ...
def validate_dpi(s: Union[float, str]) -> Union[float, str]:
    """Confirm s is string 'figure' or convert s to float or raise."""
    ...

validate_string = ...
validate_string_or_None = ...
validate_stringlist = ...
validate_int = ...
validate_int_or_None = ...
validate_float = ...
validate_float_or_None = ...
validate_floatlist = ...

def validate_fonttype(s: Union[int, str]) -> int:
    """
    Confirm that this is a Postscript or PDF font type that we know how to
    convert to.
    """
    ...

def validate_backend(s: str) -> str: ...
def validate_color_or_inherit(s: str) -> str:
    """Return a valid color arg."""
    ...

def validate_color_or_auto(s: str) -> str: ...
def validate_color_for_prop_cycle(s: str) -> str: ...
def validate_color(s: str) -> str:
    """Return a valid color arg."""
    ...

validate_colorlist = ...

def validate_aspect(s: str) -> str: ...
def validate_fontsize_None(s: Optional[str]) -> None: ...
def validate_fontsize(s: Union[int, float, str]) -> Union[float, str]: ...

validate_fontsizelist = ...

def validate_fontweight(s: str) -> str: ...
def validate_fontstretch(s: str) -> str: ...
def validate_font_properties(s: str) -> str: ...
def validate_whiskers(s: Union[float, str]) -> float: ...
def validate_ps_distiller(s: Optional[str]) -> None: ...

validate_fillstyle = ...
validate_fillstylelist = ...

def validate_markevery(
    s: None | int | slice | float | list[int],
) -> tuple[None, int, slice, float, list[int]]:
    """
    Validate the markevery property of a Line2D object.

    Parameters
    ----------
    s : None, int, (int, int), slice, float, (float, float), or list[int]

    Returns
    -------
    None, int, (int, int), slice, float, (float, float), or list[int]
    """
    ...

validate_markeverylist = ...

def validate_bbox(s: Optional[str]) -> None: ...
def validate_sketch(
    s: Optional[Union[Tuple[int, int, int], str]]
) -> Optional[Tuple[float, float, float]]: ...
def validate_hatch(s):
    r"""
    Validate a hatch pattern.
    A hatch pattern string can have any sequence of the following
    characters: ``\ / | - + * . x o O``.
    """
    ...

validate_hatchlist = ...
validate_dashlist = ...

def cycler(*args, **kwargs) -> Cycler:
    """
    Create a `~cycler.Cycler` object much like :func:`cycler.cycler`,
    but includes input validation.

    Call signatures::

      cycler(cycler)
      cycler(label=values[, label2=values2[, ...]])
      cycler(label, values)

    Form 1 copies a given `~cycler.Cycler` object.

    Form 2 creates a `~cycler.Cycler` which cycles over one or more
    properties simultaneously. If multiple properties are given, their
    value lists must have the same length.

    Form 3 creates a `~cycler.Cycler` for a single property. This form
    exists for compatibility with the original cycler. Its use is
    discouraged in favor of the kwarg form, i.e. ``cycler(label=values)``.

    Parameters
    ----------
    cycler : Cycler
        Copy constructor for Cycler.

    label : str
        The property key. Must be a valid `.Artist` property.
        For example, 'color' or 'linestyle'. Aliases are allowed,
        such as 'c' for 'color' and 'lw' for 'linewidth'.

    values : iterable
        Finite-length iterable of the property values. These values
        are validated and will raise a ValueError if invalid.

    Returns
    -------
    Cycler
        A new :class:`~cycler.Cycler` for the given properties.

    Examples
    --------
    Creating a cycler for a single property:

    >>> c = cycler(color=['red', 'green', 'blue'])

    Creating a cycler for simultaneously cycling over multiple properties
    (e.g. red circle, green plus, blue cross):

    >>> c = cycler(color=['red', 'green', 'blue'],
    ...            marker=['o', '+', 'x'])

    """
    ...

class _DunderChecker(ast.NodeVisitor):
    def visit_Attribute(self, node): ...

def validate_cycler(s: Union[Cycler, str]) -> Cycler:
    """Return a Cycler object from a string repr or the object itself."""
    ...

def validate_hist_bins(s: Union[int, str]) -> int: ...

class _ignorecase(list):
    """A marker class indicating that a list-of-str is case-insensitive."""

    ...
