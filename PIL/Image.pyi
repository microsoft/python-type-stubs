# pyright: strict

from collections.abc import MutableMapping
from pathlib import Path
from typing import (Any, BinaryIO, Callable, ContextManager, Dict, List,
                    Optional, Sequence, Tuple, Union)

from PIL.ImageFilter import Filter
from PIL.ImagePalette import ImagePalette

_Size = Tuple[int, int]

NONE: int

FLIP_LEFT_RIGHT: int
FLIP_TOP_BOTTOM: int
ROTATE_90: int
ROTATE_180: int
ROTATE_270: int
TRANSPOSE: int
TRANSVERSE: int

AFFINE: int
EXTENT: int
PERSPECTIVE: int
QUAD: int
MESH: int

NEAREST: int
BOX: int
LINEAR: int
BILINEAR: int
HAMMING: int
BICUBIC: int
CUBIC: int
LANCZOS: int
ANTIALIAS: int

ORDERED: int
RASTERIZE: int
FLOYDSTEINBERG: int

WEB: int
ADAPTIVE: int

MEDIANCUT: int
MAXCOVERAGE: int
FASTOCTREE: int
LIBIMAGEQUANT: int

NORMAL: int
SEQUENCE: int
CONTAINER: int

def open(fp: Union[str, Path, BinaryIO], mode: str = ...) -> Image: ...

def alpha_composite(im1: Image, im2: Image) -> Image: ...

def blend(im1: Image, im2: Image, alpha: float) -> Image: ...

def composite(image1: Image, image2: Image, mask: Image) -> Image: ...

# TODO: args
def eval(image: Image, *args: Any) -> Image: ...

def merge(mode: str, bands: Sequence[Image]) -> Image: ...

def new(mode: str, size: _Size, color: Optional[Union[str, Tuple[int, ...]]] = ...) -> Image: ...

# TODO: Buffer protocol
def fromarray(obj: Any, mode: Optional[str] = ...) -> Image: ...

# TODO: Decoder protocol
def frombytes(mode: str, size: _Size, data: Any, decoder_name: str = ..., *args: Any) -> Image: ...

# TODO: raises NotImplementedError unconditionally; remove?
def fromstring(*args: Any, **kwargs: Any) -> None: ...

# TODO: Decoder protocol
def frombuffer(mode: str, size: _Size, data: Any, decoder_name: str = ..., *args: Any) -> Image: ...

def register_open(id: str, factory: Callable, accept: Optional[Callable] = ...) -> None: ...

def register_decoder(name: str, decoder: Callable) -> None: ...

def register_mime(name: str, mimetype: str) -> None: ...

def register_save(id: str, driver: Callable) -> None: ...

def register_encoder(name: str, encoder: Callable) -> None: ...

def register_extension(id: str, extension: str) -> None: ...

class Image(ContextManager[Image]):
    filename: str
    format: Optional[str]
    mode: str
    palette: Optional[ImagePalette]
    info: Dict[Any, Any]

    def __init__(self) -> None: ...

    def alpha_composite(self, im: Image, dest: Tuple[int, int] = ..., source: Tuple[int, int] = ...) -> None: ...

    # TODO: Literal for palette from constants
    def convert(self, mode: Optional[str] = ..., matrix: Optional[Tuple[float, ...]] = ..., dither: Optional[str] = ..., palette: int = ..., colors: int = ...) -> Image: ...

    def copy(self) -> Image: ...

    def crop(self, box: Optional[Tuple[int, int, int, int]] = ...) -> Image: ...

    def draft(self, mode: str, size: _Size) -> None: ...

    def filter(self, filter: Union[Filter, Callable[..., Filter]]) -> Image: ...

    def frombytes(self, data: Any, decoder_name: str = ..., *args: Any) -> Image: ...

    def getbands(self) -> Tuple[str, ...]: ...

    def getbbox(self) -> Tuple[int, int, int, int]: ...

    def getchannel(self, channel: Union[int, str]) -> Image: ...

    def getcolors(self, maxcolors: int = ...) -> List[Tuple[int, int]]: ...

    def getdata(self, band: Optional[int] = ...) -> Sequence[Any]: ...

    def getexif(self) -> Exif: ...

    def getextrema(self) -> Union[Tuple[int, int], Tuple[Tuple[int, int], ...]]: ...

    def getpalette(self) -> List[int]: ...

    def getpixel(self, xy: Tuple[int, int]) -> Union[int, Tuple[int, ...]]: ...

    def getprojection(self) -> Tuple[List[int], List[int]]: ...

    # TODO: Better type for extrema
    def histogram(self, mask: Optional[Image] = ..., extrema: Optional[Tuple[Any, ...]] = ...) -> List[int]: ...

    # TODO: raises NotImplementedError unconditionally; remove?
    def offset(self, xoffset: Any, yoffset: Any = ...) -> None: ...

    def paste(self, im: Union[Image, int, Tuple[int, ...]], box: Optional[Union[Tuple[int, int, int, int], Tuple[int, int]]] = ..., mask: Optional[Image] = ...) -> None: ...

    # TODO: type lut
    def point(self, lut: Any, mode: Optional[str] = ...) -> Image: ...

    # TODO: "color value"?
    def putalpha(self, alpha: Union[Image, int]) -> None: ...

    # TODO: Sequence of what?
    def putdata(self, data: Sequence[Any], scale: float = ..., offset: float = ...) -> None: ...

    def putpalette(self, data: Union[List[int], str], rawmode: str = ...) -> None: ...

    def putpixel(self, xy: Tuple[int, int], value: Union[int, Tuple[int, ...]]) -> None: ...

    # TODO: type palette
    def quantize(self, colors: int = ..., method: Optional[int] = ..., kmneans: int = ..., palette: Optional[Any] = ..., dither: int = ...) -> Image: ...

    def reduce(self, factor: Union[int, Tuple[int, int]], box: Optional[Tuple[int, int, int, int]] = ...) -> None: ...

    def remap_palette(self, dest_map: Sequence[int], source_palette: Optional[bytes] = ...) -> Image: ...

    def resize(self, size: _Size, resample: int = ..., box: Optional[Tuple[int, int, int, int]] = ..., reducing_gap: Optional[float] = ...) -> Image: ...

    # TODO: type fillcolor
    def rotate(self, angle: float, resample: int = ..., expand: Union[int, bool] = ..., center: Optional[Tuple[int, int]] = ..., translate: Optional[Tuple[int, int]] = ..., fillcolor: Optional[Any] = ...) -> Image: ...

    def save(self, fp: Union[str, Path, BinaryIO], format: Optional[str] = ..., **params: Any) -> None: ...

    def seek(self, frame: int) -> None: ...

    def show(self, title: Optional[str] = ..., command: Optional[str] = ...) -> None: ...

    # TODO: type "bands"
    def split(self) -> Tuple[Any, ...]: ...

    def tell(self) -> int: ...

    def thumbnail(self, size: _Size, resample: int = ..., reducing_gap: float = ...) -> None: ...

    def tobitmap(self, name: str = ...) -> str: ...

    def tobytes(self, encoder_name: str = ..., *args: Any) -> bytes: ...

    # TODO: type fillcolor
    def transform(self, size: _Size, method: int = ..., data: Optional[Any] = ..., resample: int = ..., fill: Any = ..., fillcolor: Optional[Any] = ...) -> Image: ...

    def transpose(self, method: int) -> Image: ...

    def verify(self) -> None: ...

    def load(self) -> None: ...

    def close(self) -> None: ...

    @property
    def width(self) -> int: ...

    @property
    def height(self) -> int: ...

    @property
    def size(self) -> _Size: ...

    class ImagePointHandler:
        def __getattr__(self, name: str) -> Any: ... # incomplete

    class ImageTransformHandler:
        def __getattr__(self, name: str) -> Any: ... # incomplete


class Exif(MutableMapping[int, Any]):
    def __init__(self) -> None: ...

    endian: str = ...

    def get_ifd(self, tag: int) -> Any: ...
    def load(self, data: bytes) -> None: ...
    def tobytes(self, offset: int = ...) -> bytes: ...
