from __future__ import annotations
import numpy as np
from pandas.core.arrays.categorical import Categorical
from pandas._typing import FrameOrSeries, Scalar, SeriesAxisType
from pandas.core.accessor import DirNamesMixin as DirNamesMixin
from pandas.core.arrays import ExtensionArray as ExtensionArray
from pandas.core.indexes.api import Index as Index
from pandas.core.series import Series
from pandas.core.frame import DataFrame
from typing import Callable, Generic, List, Optional, Tuple, TypeVar, Union, overload

class PandasObject(DirNamesMixin):
    def __sizeof__(self) -> int: ...

class NoNewAttributesMixin:
    def __setattr__(self, key, value) -> None: ...

class GroupByError(Exception): ...
class DataError(GroupByError): ...
class SpecificationError(GroupByError): ...

class SelectionMixin:
    def ndim(self) -> int: ...
    def __getitem__(self, key): ...
    def aggregate(self, func: Optional[Callable] = ..., *args, **kwargs) -> Union[Scalar, Series, DataFrame]: ...
    agg = aggregate

class ShallowMixin: ...

_T = TypeVar("_T", str, int)

class IndexOpsMixin(Generic[_T]):
    __array_priority__: int = ...
    def transpose(self, *args, **kwargs) -> Index[_T]: ...
    T = transpose
    @property
    def shape(self) -> tuple: ...
    @property
    def ndim(self) -> int: ...
    def item(self): ...
    @property
    def nbytes(self) -> int: ...
    @property
    def size(self) -> int: ...
    @property
    def array(self) -> ExtensionArray: ...
    @overload
    def to_numpy(self: Index[str]) -> np.ndarray: ...
    @overload
    def to_numpy(self: Index[int]) -> np.ndarray: ...
    @property
    def empty(self) -> bool: ...
    def max(self, axis = ..., skipna: bool = ..., *args, **kwargs): ...
    def min(self, axis = ..., skipna: bool = ..., *args, **kwargs): ...
    def argmax(self, axis: Optional[SeriesAxisType] = ..., skipna: bool = ..., *args, **kwargs) -> np.ndarray: ...
    def argmin(self, axis: Optional[SeriesAxisType] = ..., skipna: bool = ..., *args, **kwargs) -> np.ndarray: ...
    def tolist(self) -> List[_T]: ...
    def __iter__(self) : ...
    def hasnans(self) -> bool: ...
    def value_counts(self, normalize: bool = ..., sort: bool = ..., ascending: bool = ..., bins = ..., dropna: bool = ...): ...
    def unique(self) -> Index[_T]: ...
    def nunique(self, dropna: bool = ...) -> int: ...
    @property
    def is_unique(self) -> bool: ...
    @property
    def is_monotonic(self) -> bool: ...
    @property
    def is_monotonic_decreasing(self) -> bool: ...
    @property
    def is_monotonic_increasing(self) -> bool: ...
    def memory_usage(self, deep: bool = ...) -> int: ...
    def factorize(
        self, sort: bool = ..., na_sentinel: int = ...
    ) -> Tuple[np.ndarray, Union[np.ndarray, Index, Categorical]]: ...
    def searchsorted(self, value, side: str = ..., sorter = ...) -> Union[int, List[int]]: ...
    def drop_duplicates(self, keep: str = ..., inplace: bool = ...) -> FrameOrSeries: ...
    def duplicated(self, keep: str = ...) -> np.ndarray: ...


