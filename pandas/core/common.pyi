from pandas._libs import lib as lib, tslibs as tslibs
from pandas._typing import T as T
from pandas.core.dtypes.cast import construct_1d_object_array_from_listlike as construct_1d_object_array_from_listlike
from pandas.core.dtypes.common import is_array_like as is_array_like, is_bool_dtype as is_bool_dtype, is_extension_array_dtype as is_extension_array_dtype, is_integer as is_integer
from pandas.core.dtypes.generic import ABCIndex as ABCIndex, ABCIndexClass as ABCIndexClass, ABCSeries as ABCSeries
from pandas.core.dtypes.missing import isna as isna, isnull as isnull, notnull as notnull
from typing import Any, Collection, Iterable, Optional, Union

class SettingWithCopyError(ValueError): ...
class SettingWithCopyWarning(Warning): ...

def flatten(l: Any) -> None: ...
def consensus_name_attr(objs: Any): ...
def maybe_box(indexer: Any, values: Any, obj: Any, key: Any): ...
def maybe_box_datetimelike(value: Any): ...

values_from_object: Any

def is_bool_indexer(key: Any) -> bool: ...
def cast_scalar_indexer(val: Any): ...
def not_none(*args: Any): ...
def any_none(*args: Any): ...
def all_none(*args: Any): ...
def any_not_none(*args: Any): ...
def all_not_none(*args: Any): ...
def count_not_none(*args: Any): ...
def try_sort(iterable: Any): ...
def asarray_tuplesafe(values: Any, dtype: Optional[Any] = ...): ...
def index_labels_to_array(labels: Any, dtype: Optional[Any] = ...): ...
def maybe_make_list(obj: Any): ...
def maybe_iterable_to_list(obj: Union[Iterable[T], T]) -> Union[Collection[T], T]: ...
def is_null_slice(obj: Any): ...
def is_true_slices(l: Any): ...
def is_full_slice(obj: Any, l: Any): ...
def get_callable_name(obj: Any): ...
def apply_if_callable(maybe_callable: Any, obj: Any, **kwargs: Any): ...
def dict_compat(d: Any): ...
def standardize_mapping(into: Any): ...
def random_state(state: Optional[Any] = ...): ...
def pipe(obj: Any, func: Any, *args: Any, **kwargs: Any): ...
def get_rename_function(mapper: Any): ...
