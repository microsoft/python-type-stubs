from __future__ import annotations
from datetime import datetime, timestamp
import sys
from typing import Any, Optional, Union

if sys.version_info >= (3, 8):
    from typing import Literal
else:
    from typing_extensions import Literal

class Timestamp(datetime):
    def __init__(
        self,
        ts_input: Any,
        freq: Any = ...,
        tz: Any = ...,
        unit: str = ...,
        year: int = ...,
        month: int = ...,
        day: int = ...,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        nanosecond: int = ...,
        tzinfo: Any = ...,
    ): ...

    # Class methods
    # Methods

class Tick(SingleConstructorOffset):
    __array_priority__: int
    def __init__(self, n: int = ..., normalize: bool = ...) -> None: ...
    @property
    def delta(self) -> int: ...
    @property
    def nanos(self) -> int: ...
    def is_on_offset(self, dt: datetime) -> bool: ...
    def is_anchored(self) -> bool: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __mul__(self, other) -> Tick: ...
    def __truediv__(self, other) -> Tick: ...
    def __add__(self, other) -> Tick: ...
    def apply(self, other) -> Any: ...
    def __setstate__(self, state: Mapping) -> None: ...

class Timestamp(timestamp):
    @staticmethod
    def combine(date, time) -> Timestamp: ...
    @staticmethod
    def fromordinal(ordinal: int, freq: Any = ..., tz: Any = ...) -> Timestamp: ...
    @staticmethod
    def fromtimestamp(ts) -> Timestamp: ...
    @staticmethod
    def now(tz = ...) -> Timestamp: ...
    @staticmethod
    def today(tz = ...) -> Timestamp: ...
    @staticmethod
    def utcfromtimestamp(ts) -> Timestamp: ...
    @staticmethod
    def utcnow() -> Timestamp: ...

    def normalize(self) -> Timestamp: ...
    def replace(
        self,
        year: Optional[int] = ...,
        month: Optional[int] = ...,
        day: Optional[int] = ...,
        hour: Optional[int] = ...,
        minute: Optional[int] = ...,
        second: Optional[int] = ...,
        microsecond: Optional[int] = ...,
        nanosecond: Optional[int] = ...,
        tzinfo: Any = ...,
        fold: int = ...,
    ) -> Timestamp: ...

    def astimezone(self, tz: Any) -> Timestamp: ...
    def ctime(self) -> str: ...
    def date(self) -> Any: ...
    def dst(self) -> Timestamp: ...
    def fromisoformat(self) -> Any: ...
    def isocalendar(self) -> Tuple[int, int, int]: ...
    def isoweekday(self) -> int: ...
    def monthname(self, local: Any) -> str: ...
    def day_name(self, local: Optional[str] = ...) -> str: ...

    def ceil(self, freq: str, ambiguous: Union[bool, str, Literal['raise', 'NaT']] = ...,
                nonexistent: Union[Timedelta, str, Literal['raise', 'shift_forward', 'shift_backward', 'NaT']] = ...) \
            -> Timestamp: ...
    def floor(self, freq: str, ambiguous: Union[bool, str, Literal['raise', 'NaT']] = ...,
                nonexistent: Union[Timedelta, str, Literal['raise', 'shift_forward', 'shift_backward', 'NaT']] = ...) \
            -> Timestamp: ...
    def round(self, freq: str, ambiguous: Union[bool, str, Literal['raise', 'NaT']] = ...,
                nonexistent: Union[Timedelta, str, Literal['raise', 'shift_forward', 'shift_backward', 'NaT']] = ...) \
            -> Timestamp: ...
    def to_julian_date(self, *args, **kwargs) -> str: ...
    def strftime(self, fmt: str) -> str: ...
    def time(self) -> Timestamp: ...
    def timestamp(self) -> float: ...
    def timetuple(self) -> Tuple: ...
    def timetz(self) -> Timestamp: ...
    def to_datetime64(self) -> _np.datetime64: ...
    def to_numpy(self) -> _np.datetime64: ...
    def to_period(self, freq: Optional[str] = ...) -> Any: ...
    def to_pydatetime(self, warn: bool = ...) -> datetime: ...
    def toordinal(self) -> Any: ...
    def tz_convert(self, tz: Any) -> Timestamp: ...
    def tz_localize(self, tz: Any, ambiguous: Any = ..., nonexistent: Any = ...) -> Timestamp: ...
    def tzname(self) -> str: ...
    def utcoffset(self) -> Any: ...
    def utctimetuple(self) -> Any: ...
    def weekday(self) -> int: ...

    @classmethod
    def utcfromtimestamp(cls, ts: Timestamp) -> Timestamp: ...
    @classmethod
    def utcnow(cls) -> Timestamp: ...
    def __init__(self, *args, **kwargs): ...
    def __new__(cls, *args, **kwargs) -> Timestamp: ...

    # Still need to do parameter types
    @property
    def asm8(self) -> int: ...
    @property
    def tz(self) -> Any: ...
    @property
    def dayofweek(self) -> int: ...
    @property
    def dayofyear(self) -> int: ...
    @property
    def daysinmonth(self) -> int: ...
    @property
    def days_in_month(self) -> int: ...
    @property
    def freqstr(self) -> str: ...
    @property
    def is_leap_year(self) -> bool: ...
    @property
    def is_month_end(self) -> bool: ...
    @property
    def is_month_start(self) -> bool: ...
    @property
    def is_quarter_end(self) -> bool: ...
    @property
    def is_quarter_start(self) -> bool: ...
    @property
    def is_year_end(self) -> bool: ...
    @property
    def is_year_start(self) -> bool: ...
    @property
    def quarter(self) -> int: ...
    @property
    def week(self) -> int: ...
    @property
    def weekofyear(self) -> int: ...

from .timedeltas import Timedelta
from .period import Period
