from __future__ import annotations
import numpy as np
import sys
from datetime import datetime, timedelta
from .timestamps import Timestamp
from pandas.tseries.offsets import DateOffset
from typing import Any, Optional, Set, Type, Union
if sys.version_info >= (3, 8):
    from typing import Literal
else:
    from typing_extensions import Literal

nat_strings: Set[str] = ...
iNaT: int = ...

class _NaT(datetime):

    __array_priority__: int = ...

    def __richcmp__(self, other: object, op: int) -> bool: ...
    def __add__(self, other) -> _NaT: ...
    def __sub__(self, other) -> _NaT: ...
    def __pos__(self) -> _NaT: ...
    def __neg__(self) -> _NaT: ...
    def __truediv__(self, other) -> _NaT: ...
    def __floordiv__(self, other) -> _NaT: ...
    def __mul__(self, other) -> _NaT: ...

    @property
    def asm8(self) -> np.datetime64: ...
    def to_datetime64(self) -> np.datetime64: ...
    def to_numpy(self, dtype: Any, copy: bool = ...) -> np.datetime64: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def isoformat(self, sep: str = ...) -> str: ...
    def __hash__(self) -> int: ...
    def __int__(self) -> _NaT: ...
    def __long__(self) -> _NaT: ...
    @property
    def is_leap_year(self) -> bool: ...
    @property
    def is_month_start(self) -> bool: ...
    @property
    def is_quarter_start(self) -> bool: ...
    @property
    def is_year_start(self) -> bool: ...
    @property
    def is_month_end(self) -> bool: ...
    @property
    def is_quarter_end(self) -> bool: ...
    @property
    def is_year_end(self) -> bool: ...

class NaTType(_NaT):
    def __new__(cls) -> NaTType: ...
    def __reduce__(self) -> Any: ...
    def __rdiv__(self, other) -> _NaT: ...
    def __rtruediv__(self, other) -> _NaT: ...
    def __rfloordiv__(self, other) -> _NaT: ...
    def __rmul__(self, other) -> _NaT: ...

    year: Type[np.nan] = ...
    quarter: Type[np.nan] = ...
    month: Type[np.nan] = ...
    day: Type[np.nan] = ...
    hour: Type[np.nan] = ...
    minute: Type[np.nan] = ...
    second: Type[np.nan] = ...
    millisecond: Type[np.nan] = ...
    microsecond: Type[np.nan] = ...
    nanosecond: Type[np.nan] = ...
    week: Type[np.nan] = ...
    dayofyear: Type[np.nan] = ...
    weekofyear: Type[np.nan] = ...
    days_in_month: Type[np.nan] = ...
    daysinmonth: Type[np.nan] = ...
    dayofweek:Type[np.nan] = ...
    days: Type[np.nan] = ...
    seconds: Type[np.nan] = ...
    microseconds: Type[np.nan] = ...
    nanoseconds: Type[np.nan] = ...
    qyear: Type[np.nan] = ...
    weekday: Type[np.nan] = ...
    isoweekday: Type[np.nan] = ...
    total_seconds: Type[np.nan] = ...
    def month_name(self, locale: Optional[str] = ...) -> str: ...
    def day_name(self, locale: Optional[str] = ...) -> str: ...

    def date(self) -> None: ...
    def utctimetuple(self) -> None: ...
    def timetz(self) -> None: ...
    def timetuple(self) -> None: ...
    def strftime(self) -> None: ...
    def isocalendar(self) -> None: ...
    def dst (self) -> None: ...
    def ctime(self) -> None: ...
    def time(self) -> None: ...
    def toordinal(self) -> None: ...
    def tzname (self) -> None: ...
    def utcoffset(self) -> None: ...
    def fromisocalendar(self) -> None: ...
    def strptime(self, string: str, format: str) -> str: ...
    def utcfromtimestamp(self, ts: Timestamp) -> datetime: ...
    def fromtimestamp(self, ts: Timestamp) -> datetime: ...
    def combine(self, date: datetime, time: datetime) -> datetime: ...
    def utcnow(self) -> Timestamp: ...
    def timestamp(self) -> float: ...
    def astimezone(self, tz: Any) -> Timestamp: ...
    def fromordinal(self, ordinal: int, freq: Optional[Union[str, DateOffset]] = ..., tz: Any = ...) -> Timestamp: ...
    def to_pydatetime(self) -> datetime: ...
    def now(self, tz = ...) -> Timestamp: ...
    def today(self, tz = ...) -> Timestamp: ...
    def round(self, freq: str, ambiguous: Union[bool, str, Literal['raise', 'NaT']] = ...,
        nonexistent: Union[str, Literal['raise', 'shift_forward', 'shift_backward', 'NaT'], timedelta] = ...) -> Timestamp: ...
    def floor(self, freq: str, ambiguous: Union[bool, str, Literal['raise', 'NaT']] = ...,
        nonexistent: Union[str, Literal['raise', 'shift_forward', 'shift_backward', 'NaT'], timedelta] = ...) -> Timestamp: ...
    def ceil(self, freq: str, ambiguous: Union[bool, str, Literal['raise', 'NaT']] = ...,
        nonexistent: Union[str, Literal['raise', 'shift_forward', 'shift_backward', 'NaT'], timedelta] = ...) -> Timestamp: ...
    def tz_convert(self, tz: Any) -> Timestamp: ...
    def tz_localizel(self, tz: Any, ambiguous: Union[bool, str, Literal['raise', 'NaT']] = ...,
        nonexistent: Union[str, Literal['raise', 'shift_forward', 'shift_backward', 'NaT'], timedelta] = ...) -> Timestamp: ...

    def replace(self,
        year: Optional[int] = ...,
        month: Optional[int] = ...,
        day: Optional[int] = ...,
        hour: Optional[int] = ...,
        minute: Optional[int] = ...,
        second: Optional[int] = ...,
        microsecond: Optional[int] = ...,
        nanosecond: Optional[int] = ...,
        tzinfo: Any = ...,
        fold: int = ...) -> Timestamp: ...


NaT: NaTType = ...

def checknull_with_nat(val: object) -> bool: ...
def is_null_datetimelike(val: object, inat_is_null: bool = ...) -> bool: ...
