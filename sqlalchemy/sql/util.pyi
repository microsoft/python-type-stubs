from . import operators as operators, visitors as visitors
from .. import exc as exc, util as util
from .base import ColumnSet as ColumnSet
from .ddl import sort_tables as sort_tables
from .elements import BindParameter as BindParameter, ColumnClause as ColumnClause, ColumnElement as ColumnElement, Null as Null, UnaryExpression as UnaryExpression
from .schema import Column as Column
from .selectable import Alias as Alias, FromClause as FromClause, FromGrouping as FromGrouping, Join as Join, ScalarSelect as ScalarSelect, SelectBase as SelectBase, TableClause as TableClause
from typing import Any, Optional

join_condition: Any

def find_join_source(clauses: Any, join_to: Any): ...
def find_left_clause_that_matches_given(clauses: Any, join_from: Any): ...
def find_left_clause_to_join_from(clauses: Any, join_to: Any, onclause: Any): ...
def visit_binary_product(fn: Any, expr: Any) -> None: ...
def find_tables(clause: Any, check_columns: bool = ..., include_aliases: bool = ..., include_joins: bool = ..., include_selects: bool = ..., include_crud: bool = ...): ...
def unwrap_order_by(clause: Any): ...
def unwrap_label_reference(element: Any): ...
def expand_column_list_from_order_by(collist: Any, order_by: Any): ...
def clause_is_present(clause: Any, search: Any): ...
def surface_selectables(clause: Any) -> None: ...
def surface_selectables_only(clause: Any) -> None: ...
def surface_column_elements(clause: Any, include_scalar_selects: bool = ...) -> None: ...
def selectables_overlap(left: Any, right: Any): ...
def bind_values(clause: Any): ...

class _repr_base:
    def trunc(self, value: Any): ...

class _repr_row(_repr_base):
    row: Any = ...
    max_chars: Any = ...
    def __init__(self, row: Any, max_chars: int = ...) -> None: ...

class _repr_params(_repr_base):
    params: Any = ...
    ismulti: Any = ...
    batches: Any = ...
    max_chars: Any = ...
    def __init__(self, params: Any, batches: Any, max_chars: int = ..., ismulti: Optional[Any] = ...) -> None: ...

def adapt_criterion_to_null(crit: Any, nulls: Any): ...
def splice_joins(left: Any, right: Any, stop_on: Optional[Any] = ...): ...
def reduce_columns(columns: Any, *clauses: Any, **kw: Any): ...
def criterion_as_pairs(expression: Any, consider_as_foreign_keys: Optional[Any] = ..., consider_as_referenced_keys: Optional[Any] = ..., any_operator: bool = ...): ...

class ClauseAdapter(visitors.ReplacingCloningVisitor):
    __traverse_options__: Any = ...
    selectable: Any = ...
    include_fn: Any = ...
    exclude_fn: Any = ...
    equivalents: Any = ...
    adapt_on_names: Any = ...
    def __init__(self, selectable: Any, equivalents: Optional[Any] = ..., include_fn: Optional[Any] = ..., exclude_fn: Optional[Any] = ..., adapt_on_names: bool = ..., anonymize_labels: bool = ...) -> None: ...
    def replace(self, col: Any): ...

class ColumnAdapter(ClauseAdapter):
    columns: Any = ...
    adapt_required: Any = ...
    allow_label_resolve: Any = ...
    def __init__(self, selectable: Any, equivalents: Optional[Any] = ..., adapt_required: bool = ..., include_fn: Optional[Any] = ..., exclude_fn: Optional[Any] = ..., adapt_on_names: bool = ..., allow_label_resolve: bool = ..., anonymize_labels: bool = ...) -> None: ...
    class _IncludeExcludeMapping:
        parent: Any = ...
        columns: Any = ...
        def __init__(self, parent: Any, columns: Any) -> None: ...
        def __getitem__(self, key: Any): ...
    def wrap(self, adapter: Any): ...
    def traverse(self, obj: Any): ...
    adapt_clause: Any = ...
    adapt_list: Any = ...
