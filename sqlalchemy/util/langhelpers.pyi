from . import compat as compat
from .. import exc as exc
from typing import Any, Optional

def md5_hex(x: Any): ...

class safe_reraise:
    warn_only: Any = ...
    def __init__(self, warn_only: bool = ...) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, type_: Any, value: Any, traceback: Any) -> None: ...

def clsname_as_plain_name(cls): ...
def decode_slice(slc: Any): ...
def map_bits(fn: Any, n: Any) -> None: ...
def decorator(target: Any): ...
def public_factory(target: Any, location: Any, class_location: Optional[Any] = ...): ...

class PluginLoader:
    group: Any = ...
    impls: Any = ...
    auto_fn: Any = ...
    def __init__(self, group: Any, auto_fn: Optional[Any] = ...) -> None: ...
    def clear(self) -> None: ...
    def load(self, name: Any): ...
    def register(self, name: Any, modulepath: Any, objname: Any): ...

def get_cls_kwargs(cls, _set: Optional[Any] = ...): ...
def get_func_kwargs(func: Any): ...
def get_callable_argspec(fn: Any, no_self: bool = ..., _is_init: bool = ...): ...
def format_argspec_plus(fn: Any, grouped: bool = ...): ...
def format_argspec_init(method: Any, grouped: bool = ...): ...
def getargspec_init(method: Any): ...
def unbound_method_to_callable(func_or_cls: Any): ...
def generic_repr(obj: Any, additional_kw: Any = ..., to_inspect: Optional[Any] = ..., omit_kwarg: Any = ...): ...

class portable_instancemethod:
    target: Any = ...
    name: Any = ...
    kwargs: Any = ...
    def __init__(self, meth: Any, kwargs: Any = ...) -> None: ...
    def __call__(self, *arg: Any, **kw: Any): ...

def class_hierarchy(cls): ...
def iterate_attributes(cls) -> None: ...
def monkeypatch_proxied_specials(into_cls: Any, from_cls: Any, skip: Optional[Any] = ..., only: Optional[Any] = ..., name: str = ..., from_instance: Optional[Any] = ...) -> None: ...
def methods_equivalent(meth1: Any, meth2: Any): ...
def as_interface(obj: Any, cls: Optional[Any] = ..., methods: Optional[Any] = ..., required: Optional[Any] = ...): ...

class memoized_property:
    fget: Any = ...
    __doc__: Any = ...
    __name__: Any = ...
    def __init__(self, fget: Any, doc: Optional[Any] = ...) -> None: ...
    def __get__(self, obj: Any, cls: Any): ...
    @classmethod
    def reset(cls, obj: Any, name: Any) -> None: ...

def memoized_instancemethod(fn: Any): ...

class group_expirable_memoized_property:
    attributes: Any = ...
    def __init__(self, attributes: Any = ...) -> None: ...
    def expire_instance(self, instance: Any) -> None: ...
    def __call__(self, fn: Any): ...
    def method(self, fn: Any): ...

class MemoizedSlots:
    def __getattr__(self, key: Any): ...

def dependency_for(modulename: Any, add_to_all: bool = ...): ...

class dependencies:
    import_deps: Any = ...
    def __init__(self, *deps: Any) -> None: ...
    def __call__(self, fn: Any): ...
    @classmethod
    def resolve_all(cls, path: Any) -> None: ...
    class _importlater:
        def __new__(cls, path: Any, addtl: Any): ...
        def __init__(self, path: Any, addtl: Any) -> None: ...
        def module(self): ...
        def __getattr__(self, key: Any): ...

def asbool(obj: Any): ...
def bool_or_str(*text: Any): ...
def asint(value: Any): ...
def coerce_kw_type(kw: Any, key: Any, type_: Any, flexi_bool: bool = ..., dest: Optional[Any] = ...) -> None: ...
def constructor_copy(obj: Any, cls: Any, *args: Any, **kw: Any): ...
def counter(): ...
def duck_type_collection(specimen: Any, default: Optional[Any] = ...): ...
def assert_arg_type(arg: Any, argtype: Any, name: Any): ...
def dictlike_iteritems(dictlike: Any): ...

class classproperty(property):
    __doc__: Any = ...
    def __init__(self, fget: Any, *arg: Any, **kw: Any) -> None: ...
    def __get__(desc: Any, self: Any, cls: Any): ...

class hybridproperty:
    func: Any = ...
    def __init__(self, func: Any) -> None: ...
    def __get__(self, instance: Any, owner: Any): ...

class hybridmethod:
    func: Any = ...
    def __init__(self, func: Any) -> None: ...
    def __get__(self, instance: Any, owner: Any): ...

class _symbol(int):
    def __new__(self, name: Any, doc: Optional[Any] = ..., canonical: Optional[Any] = ...): ...
    def __reduce__(self): ...

class symbol:
    symbols: Any = ...
    def __new__(cls, name: Any, doc: Optional[Any] = ..., canonical: Optional[Any] = ...): ...
    @classmethod
    def parse_user_argument(cls, arg: Any, choices: Any, name: Any, resolve_symbol_names: bool = ...): ...

def set_creation_order(instance: Any) -> None: ...
def warn_exception(func: Any, *args: Any, **kwargs: Any): ...
def ellipses_string(value: Any, len_: int = ...): ...

class _hash_limit_string(compat.text_type):
    def __new__(cls, value: Any, num: Any, args: Any): ...
    def __hash__(self) -> Any: ...
    def __eq__(self, other: Any) -> Any: ...

def warn(msg: Any) -> None: ...
def warn_limited(msg: Any, args: Any) -> None: ...
def only_once(fn: Any, retry_on_exception: Any): ...
def chop_traceback(tb: Any, exclude_prefix: Any = ..., exclude_suffix: Any = ...): ...

NoneType: Any

def attrsetter(attrname: Any): ...

class EnsureKWArgType(type):
    def __init__(cls, clsname: Any, bases: Any, clsdict: Any) -> None: ...

def wrap_callable(wrapper: Any, fn: Any): ...
def quoted_token_parser(value: Any): ...
def add_parameter_text(params: Any, text: Any): ...
def inject_docstring_text(doctext: Any, injecttext: Any, pos: Any): ...
def inject_param_text(doctext: Any, inject_params: Any): ...
