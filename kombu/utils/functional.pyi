"""
This type stub file was generated by pyright.
"""

import sys
from collections import UserDict

"""Functional Utilities."""
KEYWORD_MARK = object()
class ChannelPromise:
    def __init__(self, contract) -> None:
        ...
    
    def __call__(self):
        ...
    
    def __repr__(self):
        ...
    


class LRUCache(UserDict):
    """LRU Cache implementation using a doubly linked list to track access.

    Arguments:
        limit (int): The maximum number of keys to keep in the cache.
            When a new key is inserted and the limit has been exceeded,
            the *Least Recently Used* key will be discarded from the
            cache.
    """
    def __init__(self, limit=...) -> None:
        ...
    
    def __getitem__(self, key):
        ...
    
    def update(self, *args, **kwargs):
        ...
    
    def popitem(self, last=...):
        ...
    
    def __setitem__(self, key, value):
        ...
    
    def __iter__(self):
        ...
    
    iteritems = ...
    itervalues = ...
    iterkeys = ...
    def incr(self, key, delta=...):
        ...
    
    def __getstate__(self):
        ...
    
    def __setstate__(self, state):
        ...
    

def memoize(maxsize=..., keyfun=..., Cache=...):
    """Decorator to cache function return value."""
    ...

class lazy:
    """Holds lazy evaluation.

    Evaluated when called or if the :meth:`evaluate` method is called.
    The function is re-evaluated on every call.

    Overloaded operations that will evaluate the promise:
        :meth:`__str__`, :meth:`__repr__`, :meth:`__cmp__`.
    """
    def __init__(self, fun, *args, **kwargs) -> None:
        ...
    
    def __call__(self):
        ...
    
    def evaluate(self):
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self):
        ...
    
    def __eq__(self, rhs) -> bool:
        ...
    
    def __ne__(self, rhs) -> bool:
        ...
    
    def __deepcopy__(self, memo):
        ...
    
    def __reduce__(self):
        ...
    


def maybe_evaluate(value):
    """Evaluate value only if value is a :class:`lazy` instance."""
    ...

def is_list(obj, scalars=..., iters=...):
    """Return true if the object is iterable.

    Note:
        Returns false if object is a mapping or string.
    """
    ...

def maybe_list(obj, scalars=...):
    """Return list of one element if ``l`` is a scalar."""
    ...

def dictfilter(d=..., **kw):
    """Remove all keys from dict ``d`` whose value is :const:`None`."""
    ...

def shufflecycle(it):
    ...

def fxrange(start=..., stop=..., step=..., repeatlast=...):
    ...

def fxrangemax(start=..., stop=..., step=..., max=...):
    ...

def retry_over_time(fun, catch, args=..., kwargs=..., errback=..., max_retries=..., interval_start=..., interval_step=..., interval_max=..., callback=..., timeout=...):
    """Retry the function over and over until max retries is exceeded.

    For each retry we sleep a for a while before we try again, this interval
    is increased for every retry until the max seconds is reached.

    Arguments:
        fun (Callable): The function to try
        catch (Tuple[BaseException]): Exceptions to catch, can be either
            tuple or a single exception class.

    Keyword Arguments:
        args (Tuple): Positional arguments passed on to the function.
        kwargs (Dict): Keyword arguments passed on to the function.
        errback (Callable): Callback for when an exception in ``catch``
            is raised.  The callback must take three arguments:
            ``exc``, ``interval_range`` and ``retries``, where ``exc``
            is the exception instance, ``interval_range`` is an iterator
            which return the time in seconds to sleep next, and ``retries``
            is the number of previous retries.
        max_retries (int): Maximum number of retries before we give up.
            If neither of this and timeout is set, we will retry forever.
            If one of this and timeout is reached, stop.
        interval_start (float): How long (in seconds) we start sleeping
            between retries.
        interval_step (float): By how much the interval is increased for
            each retry.
        interval_max (float): Maximum number of seconds to sleep
            between retries.
        timeout (int): Maximum seconds waiting before we give up.
    """
    ...

def reprkwargs(kwargs, sep=..., fmt=...):
    ...

def reprcall(name, args=..., kwargs=..., sep=...):
    ...

def accepts_argument(func, argument_name):
    ...

promise = lazy
maybe_promise = maybe_evaluate
