"""
This type stub file was generated by pyright.
"""

from .abstract import MaybeChannelBound, Object
from .exceptions import ContentDisallowed

"""Exchange and Queue declarations."""
TRANSIENT_DELIVERY_MODE = 1
PERSISTENT_DELIVERY_MODE = 2
DELIVERY_MODES = { 'transient': TRANSIENT_DELIVERY_MODE,'persistent': PERSISTENT_DELIVERY_MODE }
INTERNAL_EXCHANGE_PREFIX = ('amq.', )
def pretty_bindings(bindings):
    ...

def maybe_delivery_mode(v, modes=..., default=...):
    """Get delivery mode by name (or none if undefined)."""
    ...

class Exchange(MaybeChannelBound):
    """An Exchange declaration.

    Arguments:
        name (str): See :attr:`name`.
        type (str): See :attr:`type`.
        channel (kombu.Connection, ChannelT): See :attr:`channel`.
        durable (bool): See :attr:`durable`.
        auto_delete (bool): See :attr:`auto_delete`.
        delivery_mode (enum): See :attr:`delivery_mode`.
        arguments (Dict): See :attr:`arguments`.
        no_declare (bool): See :attr:`no_declare`

    Attributes:
        name (str): Name of the exchange.
            Default is no name (the default exchange).

        type (str):
            *This description of AMQP exchange types was shamelessly stolen
            from the blog post `AMQP in 10 minutes: Part 4`_ by
            Rajith Attapattu. Reading this article is recommended if you're
            new to amqp.*

            "AMQP defines four default exchange types (routing algorithms) that
            covers most of the common messaging use cases. An AMQP broker can
            also define additional exchange types, so see your broker
            manual for more information about available exchange types.

                * `direct` (*default*)

                    Direct match between the routing key in the message,
                    and the routing criteria used when a queue is bound to
                    this exchange.

                * `topic`

                    Wildcard match between the routing key and the routing
                    pattern specified in the exchange/queue binding.
                    The routing key is treated as zero or more words delimited
                    by `"."` and supports special wildcard characters. `"*"`
                    matches a single word and `"#"` matches zero or more words.

                * `fanout`

                    Queues are bound to this exchange with no arguments. Hence
                    any message sent to this exchange will be forwarded to all
                    queues bound to this exchange.

                * `headers`

                    Queues are bound to this exchange with a table of arguments
                    containing headers and values (optional). A special
                    argument named "x-match" determines the matching algorithm,
                    where `"all"` implies an `AND` (all pairs must match) and
                    `"any"` implies `OR` (at least one pair must match).

                    :attr:`arguments` is used to specify the arguments.


                .. _`AMQP in 10 minutes: Part 4`:
                    https://bit.ly/2rcICv5

        channel (ChannelT): The channel the exchange is bound to (if bound).

        durable (bool): Durable exchanges remain active when a server restarts.
            Non-durable exchanges (transient exchanges) are purged when a
            server restarts.  Default is :const:`True`.

        auto_delete (bool): If set, the exchange is deleted when all queues
            have finished using it. Default is :const:`False`.

        delivery_mode (enum): The default delivery mode used for messages.
            The value is an integer, or alias string.

                * 1 or `"transient"`

                    The message is transient. Which means it is stored in
                    memory only, and is lost if the server dies or restarts.

                * 2 or "persistent" (*default*)
                    The message is persistent. Which means the message is
                    stored both in-memory, and on disk, and therefore
                    preserved if the server dies or restarts.

            The default value is 2 (persistent).

        arguments (Dict): Additional arguments to specify when the exchange
            is declared.

        no_declare (bool): Never declare this exchange
            (:meth:`declare` does nothing).
    """
    TRANSIENT_DELIVERY_MODE = ...
    PERSISTENT_DELIVERY_MODE = ...
    name = ...
    type = ...
    durable = ...
    auto_delete = ...
    passive = ...
    delivery_mode = ...
    no_declare = ...
    attrs = ...
    def __init__(self, name=..., type=..., channel=..., **kwargs) -> None:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def declare(self, nowait=..., passive=..., channel=...):
        """Declare the exchange.

        Creates the exchange on the broker, unless passive is set
        in which case it will only assert that the exchange exists.

        Argument:
            nowait (bool): If set the server will not respond, and a
                response will not be waited for. Default is :const:`False`.
        """
        ...
    
    def bind_to(self, exchange=..., routing_key=..., arguments=..., nowait=..., channel=..., **kwargs):
        """Bind the exchange to another exchange.

        Arguments:
            nowait (bool): If set the server will not respond, and the call
                will not block waiting for a response.
                Default is :const:`False`.
        """
        ...
    
    def unbind_from(self, source=..., routing_key=..., nowait=..., arguments=..., channel=...):
        """Delete previously created exchange binding from the server."""
        ...
    
    def Message(self, body, delivery_mode=..., properties=..., **kwargs):
        """Create message instance to be sent with :meth:`publish`.

        Arguments:
            body (Any): Message body.

            delivery_mode (bool): Set custom delivery mode.
                Defaults to :attr:`delivery_mode`.

            priority (int): Message priority, 0 to broker configured
                max priority, where higher is better.

            content_type (str): The messages content_type.  If content_type
                is set, no serialization occurs as it is assumed this is either
                a binary object, or you've done your own serialization.
                Leave blank if using built-in serialization as our library
                properly sets content_type.

            content_encoding (str): The character set in which this object
                is encoded. Use "binary" if sending in raw binary objects.
                Leave blank if using built-in serialization as our library
                properly sets content_encoding.

            properties (Dict): Message properties.

            headers (Dict): Message headers.
        """
        ...
    
    def publish(self, message, routing_key=..., mandatory=..., immediate=..., exchange=...):
        """Publish message.

        Arguments:
            message (Union[kombu.Message, str, bytes]):
                Message to publish.
            routing_key (str): Message routing key.
            mandatory (bool): Currently not supported.
            immediate (bool): Currently not supported.
        """
        ...
    
    def delete(self, if_unused=..., nowait=...):
        """Delete the exchange declaration on server.

        Arguments:
            if_unused (bool): Delete only if the exchange has no bindings.
                Default is :const:`False`.
            nowait (bool): If set the server will not respond, and a
                response will not be waited for. Default is :const:`False`.
        """
        ...
    
    def binding(self, routing_key=..., arguments=..., unbind_arguments=...):
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __repr__(self):
        ...
    
    def __str__(self) -> str:
        ...
    
    @property
    def can_cache_declaration(self):
        ...
    


class binding(Object):
    """Represents a queue or exchange binding.

    Arguments:
        exchange (Exchange): Exchange to bind to.
        routing_key (str): Routing key used as binding key.
        arguments (Dict): Arguments for bind operation.
        unbind_arguments (Dict): Arguments for unbind operation.
    """
    attrs = ...
    def __init__(self, exchange=..., routing_key=..., arguments=..., unbind_arguments=...) -> None:
        ...
    
    def declare(self, channel, nowait=...):
        """Declare destination exchange."""
        ...
    
    def bind(self, entity, nowait=..., channel=...):
        """Bind entity to this binding."""
        ...
    
    def unbind(self, entity, nowait=..., channel=...):
        """Unbind entity from this binding."""
        ...
    
    def __repr__(self):
        ...
    
    def __str__(self) -> str:
        ...
    


class Queue(MaybeChannelBound):
    """A Queue declaration.

    Arguments:
        name (str): See :attr:`name`.
        exchange (Exchange, str): See :attr:`exchange`.
        routing_key (str): See :attr:`routing_key`.
        channel (kombu.Connection, ChannelT): See :attr:`channel`.
        durable (bool): See :attr:`durable`.
        exclusive (bool): See :attr:`exclusive`.
        auto_delete (bool): See :attr:`auto_delete`.
        queue_arguments (Dict): See :attr:`queue_arguments`.
        binding_arguments (Dict): See :attr:`binding_arguments`.
        consumer_arguments (Dict): See :attr:`consumer_arguments`.
        no_declare (bool): See :attr:`no_declare`.
        on_declared (Callable): See :attr:`on_declared`.
        expires (float): See :attr:`expires`.
        message_ttl (float): See :attr:`message_ttl`.
        max_length (int): See :attr:`max_length`.
        max_length_bytes (int): See :attr:`max_length_bytes`.
        max_priority (int): See :attr:`max_priority`.

    Attributes:
        name (str): Name of the queue.
            Default is no name (default queue destination).

        exchange (Exchange): The :class:`Exchange` the queue binds to.

        routing_key (str): The routing key (if any), also called *binding key*.

            The interpretation of the routing key depends on
            the :attr:`Exchange.type`.

            * direct exchange

                Matches if the routing key property of the message and
                the :attr:`routing_key` attribute are identical.

            * fanout exchange

                Always matches, even if the binding does not have a key.

            * topic exchange

                Matches the routing key property of the message by a primitive
                pattern matching scheme. The message routing key then consists
                of words separated by dots (`"."`, like domain names), and
                two special characters are available; star (`"*"`) and hash
                (`"#"`). The star matches any word, and the hash matches
                zero or more words. For example `"*.stock.#"` matches the
                routing keys `"usd.stock"` and `"eur.stock.db"` but not
                `"stock.nasdaq"`.

        channel (ChannelT): The channel the Queue is bound to (if bound).

        durable (bool): Durable queues remain active when a server restarts.
            Non-durable queues (transient queues) are purged if/when
            a server restarts.
            Note that durable queues do not necessarily hold persistent
            messages, although it does not make sense to send
            persistent messages to a transient queue.

            Default is :const:`True`.

        exclusive (bool): Exclusive queues may only be consumed from by the
            current connection. Setting the 'exclusive' flag
            always implies 'auto-delete'.

            Default is :const:`False`.

        auto_delete (bool): If set, the queue is deleted when all consumers
            have finished using it. Last consumer can be canceled
            either explicitly or because its channel is closed. If
            there was no consumer ever on the queue, it won't be
            deleted.

        expires (float): Set the expiry time (in seconds) for when this
            queue should expire.

            The expiry time decides how long the queue can stay unused
            before it's automatically deleted.
            *Unused* means the queue has no consumers, the queue has not been
            redeclared, and ``Queue.get`` has not been invoked for a duration
            of at least the expiration period.

            See https://www.rabbitmq.com/ttl.html#queue-ttl

            **RabbitMQ extension**: Only available when using RabbitMQ.

        message_ttl (float): Message time to live in seconds.

            This setting controls how long messages can stay in the queue
            unconsumed. If the expiry time passes before a message consumer
            has received the message, the message is deleted and no consumer
            will see the message.

            See https://www.rabbitmq.com/ttl.html#per-queue-message-ttl

            **RabbitMQ extension**: Only available when using RabbitMQ.

        max_length (int): Set the maximum number of messages that the
            queue can hold.

            If the number of messages in the queue size exceeds this limit,
            new messages will be dropped (or dead-lettered if a dead letter
            exchange is active).

            See https://www.rabbitmq.com/maxlength.html

            **RabbitMQ extension**: Only available when using RabbitMQ.

        max_length_bytes (int): Set the max size (in bytes) for the total
            of messages in the queue.

            If the total size of all the messages in the queue exceeds this
            limit, new messages will be dropped (or dead-lettered if a dead
            letter exchange is active).

            **RabbitMQ extension**: Only available when using RabbitMQ.

        max_priority (int): Set the highest priority number for this queue.

            For example if the value is 10, then messages can delivered to
            this queue can have a ``priority`` value between 0 and 10,
            where 10 is the highest priority.

            RabbitMQ queues without a max priority set will ignore
            the priority field in the message, so if you want priorities
            you need to set the max priority field to declare the queue
            as a priority queue.

            **RabbitMQ extension**: Only available when using RabbitMQ.

        queue_arguments (Dict): Additional arguments used when declaring
            the queue.  Can be used to to set the arguments value
            for RabbitMQ/AMQP's ``queue.declare``.

        binding_arguments (Dict): Additional arguments used when binding
            the queue.  Can be used to to set the arguments value
            for RabbitMQ/AMQP's ``queue.declare``.

        consumer_arguments (Dict): Additional arguments used when consuming
            from this queue.  Can be used to to set the arguments value
            for RabbitMQ/AMQP's ``basic.consume``.

        alias (str): Unused in Kombu, but applications can take advantage
            of this,  for example to give alternate names to queues with
            automatically generated queue names.

        on_declared (Callable): Optional callback to be applied when the
            queue has been declared (the ``queue_declare`` operation is
            complete).  This must be a function with a signature that
            accepts at least 3 positional arguments:
            ``(name, messages, consumers)``.

        no_declare (bool): Never declare this queue, nor related
            entities (:meth:`declare` does nothing).
    """
    ContentDisallowed = ...
    name = ...
    exchange = ...
    routing_key = ...
    durable = ...
    exclusive = ...
    auto_delete = ...
    no_ack = ...
    attrs = ...
    def __init__(self, name=..., exchange=..., routing_key=..., channel=..., bindings=..., on_declared=..., **kwargs) -> None:
        ...
    
    def bind(self, channel):
        ...
    
    def __hash__(self) -> int:
        ...
    
    def when_bound(self):
        ...
    
    def declare(self, nowait=..., channel=...):
        """Declare queue and exchange then binds queue to exchange."""
        ...
    
    def queue_declare(self, nowait=..., passive=..., channel=...):
        """Declare queue on the server.

        Arguments:
            nowait (bool): Do not wait for a reply.
            passive (bool): If set, the server will not create the queue.
                The client can use this to check whether a queue exists
                without modifying the server state.
        """
        ...
    
    def queue_bind(self, nowait=..., channel=...):
        """Create the queue binding on the server."""
        ...
    
    def bind_to(self, exchange=..., routing_key=..., arguments=..., nowait=..., channel=...):
        ...
    
    def get(self, no_ack=..., accept=...):
        """Poll the server for a new message.

        This method provides direct access to the messages in a
        queue using a synchronous dialogue, designed for
        specific types of applications where synchronous functionality
        is more important than performance.

        Returns:
            ~kombu.Message: if a message was available,
                or :const:`None` otherwise.

        Arguments:
            no_ack (bool): If enabled the broker will
                automatically ack messages.
            accept (Set[str]): Custom list of accepted content types.
        """
        ...
    
    def purge(self, nowait=...):
        """Remove all ready messages from the queue."""
        ...
    
    def consume(self, consumer_tag=..., callback=..., no_ack=..., nowait=...):
        """Start a queue consumer.

        Consumers last as long as the channel they were created on, or
        until the client cancels them.

        Arguments:
            consumer_tag (str): Unique identifier for the consumer.
                The consumer tag is local to a connection, so two clients
                can use the same consumer tags. If this field is empty
                the server will generate a unique tag.

            no_ack (bool): If enabled the broker will automatically
                ack messages.

            nowait (bool): Do not wait for a reply.

            callback (Callable): callback called for each delivered message.
        """
        ...
    
    def cancel(self, consumer_tag):
        """Cancel a consumer by consumer tag."""
        ...
    
    def delete(self, if_unused=..., if_empty=..., nowait=...):
        """Delete the queue.

        Arguments:
            if_unused (bool): If set, the server will only delete the queue
                if it has no consumers. A channel error will be raised
                if the queue has consumers.

            if_empty (bool): If set, the server will only delete the queue if
                it is empty. If it is not empty a channel error will be raised.

            nowait (bool): Do not wait for a reply.
        """
        ...
    
    def queue_unbind(self, arguments=..., nowait=..., channel=...):
        ...
    
    def unbind_from(self, exchange=..., routing_key=..., arguments=..., nowait=..., channel=...):
        """Unbind queue by deleting the binding from the server."""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    
    def __repr__(self):
        ...
    
    @property
    def can_cache_declaration(self):
        ...
    
    @classmethod
    def from_dict(cls, queue, **options):
        ...
    
    def as_dict(self, recurse=...):
        ...
    


