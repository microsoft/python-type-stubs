"""
This type stub file was generated by pyright.
"""

import heapq
import sys
from collections import namedtuple
from datetime import datetime
from functools import total_ordering
from kombu.log import get_logger
from pytz import utc

"""Timer scheduling Python callbacks."""
logger = get_logger(__name__)
DEFAULT_MAX_INTERVAL = 2
EPOCH = datetime.utcfromtimestamp(0).replace(tzinfo=utc)
IS_PYPY = hasattr(sys, 'pypy_version_info')
scheduled = namedtuple('scheduled', ('eta', 'priority', 'entry'))
def to_timestamp(d, default_timezone=..., time=...):
    """Convert datetime to timestamp.

    If d' is already a timestamp, then that will be used.
    """
    ...

@total_ordering
class Entry:
    """Schedule Entry."""
    def __init__(self, fun, args=..., kwargs=...) -> None:
        ...
    
    def __call__(self):
        ...
    
    def cancel(self):
        ...
    
    def __repr__(self):
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    @property
    def cancelled(self):
        ...
    
    @cancelled.setter
    def cancelled(self, value):
        ...
    


class Timer:
    """Async timer implementation."""
    Entry = ...
    on_error = ...
    def __init__(self, max_interval=..., on_error=..., **kwargs) -> None:
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info):
        ...
    
    def call_at(self, eta, fun, args=..., kwargs=..., priority=...):
        ...
    
    def call_after(self, secs, fun, args=..., kwargs=..., priority=...):
        ...
    
    def call_repeatedly(self, secs, fun, args=..., kwargs=..., priority=...):
        ...
    
    def enter_at(self, entry, eta=..., priority=..., time=...):
        """Enter function into the scheduler.

        Arguments:
            entry (~kombu.asynchronous.timer.Entry): Item to enter.
            eta (datetime.datetime): Scheduled time.
            priority (int): Unused.
        """
        ...
    
    def enter_after(self, secs, entry, priority=..., time=...):
        ...
    
    def apply_entry(self, entry):
        ...
    
    def handle_error(self, exc_info):
        ...
    
    def stop(self):
        ...
    
    def __iter__(self, min=..., nowfun=..., pop=..., push=...):
        """Iterate over schedule.

        This iterator yields a tuple of ``(wait_seconds, entry)``,
        where if entry is :const:`None` the caller should wait
        for ``wait_seconds`` until it polls the schedule again.
        """
        ...
    
    def clear(self):
        ...
    
    def cancel(self, tref):
        ...
    
    def __len__(self):
        ...
    
    def __nonzero__(self):
        ...
    
    def queue(self, _pop=heapq.heappop):
        """Snapshot of underlying datastructure."""
        ...
    
    @property
    def schedule(self):
        ...
    


