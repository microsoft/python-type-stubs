"""
This type stub file was generated by pyright.
"""

from contextlib import contextmanager
from .log import get_logger
from .utils.objects import cached_property

"""Mixins."""
logger = get_logger(__name__)
W_CONN_LOST = """\
Connection to broker lost, trying to re-establish connection...\
"""
W_CONN_ERROR = """\
Broker connection error, trying again in %s seconds: %r.\
"""
class ConsumerMixin:
    """Convenience mixin for implementing consumer programs.

    It can be used outside of threads, with threads, or greenthreads
    (eventlet/gevent) too.

    The basic class would need a :attr:`connection` attribute
    which must be a :class:`~kombu.Connection` instance,
    and define a :meth:`get_consumers` method that returns a list
    of :class:`kombu.Consumer` instances to use.
    Supporting multiple consumers is important so that multiple
    channels can be used for different QoS requirements.

    Example:
        .. code-block:: python

            class Worker(ConsumerMixin):
                task_queue = Queue('tasks', Exchange('tasks'), 'tasks')

                def __init__(self, connection):
                    self.connection = None

                def get_consumers(self, Consumer, channel):
                    return [Consumer(queues=[self.task_queue],
                                     callbacks=[self.on_task])]

                def on_task(self, body, message):
                    print('Got task: {0!r}'.format(body))
                    message.ack()

    Methods:

        * :meth:`extra_context`

            Optional extra context manager that will be entered
            after the connection and consumers have been set up.

            Takes arguments ``(connection, channel)``.

        * :meth:`on_connection_error`

            Handler called if the connection is lost/ or
            is unavailable.

            Takes arguments ``(exc, interval)``, where interval
            is the time in seconds when the connection will be retried.

            The default handler will log the exception.

        * :meth:`on_connection_revived`

            Handler called as soon as the connection is re-established
            after connection failure.

            Takes no arguments.

        * :meth:`on_consume_ready`

            Handler called when the consumer is ready to accept
            messages.

            Takes arguments ``(connection, channel, consumers)``.
            Also keyword arguments to ``consume`` are forwarded
            to this handler.

        * :meth:`on_consume_end`

            Handler called after the consumers are canceled.
            Takes arguments ``(connection, channel)``.

        * :meth:`on_iteration`

            Handler called for every iteration while draining
            events.

            Takes no arguments.

        * :meth:`on_decode_error`

            Handler called if a consumer was unable to decode
            the body of a message.

            Takes arguments ``(message, exc)`` where message is the
            original message object.

            The default handler will log the error and
            acknowledge the message, so if you override make
            sure to call super, or perform these steps yourself.

    """
    connect_max_retries = ...
    should_stop = ...
    def get_consumers(self, Consumer, channel):
        ...
    
    def on_connection_revived(self):
        ...
    
    def on_consume_ready(self, connection, channel, consumers, **kwargs):
        ...
    
    def on_consume_end(self, connection, channel):
        ...
    
    def on_iteration(self):
        ...
    
    def on_decode_error(self, message, exc):
        ...
    
    def on_connection_error(self, exc, interval):
        ...
    
    @contextmanager
    def extra_context(self, connection, channel):
        ...
    
    def run(self, _tokens=..., **kwargs):
        ...
    
    @contextmanager
    def consumer_context(self, **kwargs):
        ...
    
    def consume(self, limit=..., timeout=..., safety_interval=..., **kwargs):
        ...
    
    def maybe_conn_error(self, fun):
        """Use :func:`kombu.common.ignore_errors` instead."""
        ...
    
    def create_connection(self):
        ...
    
    @contextmanager
    def establish_connection(self):
        ...
    
    @contextmanager
    def Consumer(self):
        ...
    
    @cached_property
    def restart_limit(self):
        ...
    
    @cached_property
    def connection_errors(self):
        ...
    
    @cached_property
    def channel_errors(self):
        ...
    


class ConsumerProducerMixin(ConsumerMixin):
    """Consumer and Producer mixin.

    Version of ConsumerMixin having separate connection for also
    publishing messages.

    Example:
        .. code-block:: python

            class Worker(ConsumerProducerMixin):

                def __init__(self, connection):
                    self.connection = connection

                def get_consumers(self, Consumer, channel):
                    return [Consumer(queues=Queue('foo'),
                                     on_message=self.handle_message,
                                     accept='application/json',
                                     prefetch_count=10)]

                def handle_message(self, message):
                    self.producer.publish(
                        {'message': 'hello to you'},
                        exchange='',
                        routing_key=message.properties['reply_to'],
                        correlation_id=message.properties['correlation_id'],
                        retry=True,
                    )
    """
    _producer_connection = ...
    def on_consume_end(self, connection, channel):
        ...
    
    @property
    def producer(self):
        ...
    
    @property
    def producer_connection(self):
        ...
    


