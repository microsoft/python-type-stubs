"""
This type stub file was generated by pyright.
"""

"""Logical Clocks and Synchronization."""
from typing import Iterable, Union


R_CLOCK = '_lamport(clock={0}, timestamp={1}, id={2} {3!r})'
class timetuple(tuple):
    """Tuple of event clock information.

    Can be used as part of a heap to keep events ordered.

    Arguments:
        clock (int):  Event clock value.
        timestamp (float): Event UNIX timestamp value.
        id (str): Event host id (e.g. ``hostname:pid``).
        obj (Any): Optional obj to associate with this event.
    """
    __slots__ = Union[str, Iterable[str]]
    def __new__(cls, clock, timestamp, id, obj=...):
        ...
    
    def __repr__(self):
        ...
    
    def __getnewargs__(self):
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __gt__(self, other) -> bool:
        ...
    
    def __le__(self, other) -> bool:
        ...
    
    def __ge__(self, other) -> bool:
        ...
    
    clock = ...
    timestamp = ...
    id = ...
    obj = ...


class LamportClock:
    """Lamport's logical clock.

    From Wikipedia:

    A Lamport logical clock is a monotonically incrementing software counter
    maintained in each process.  It follows some simple rules:

        * A process increments its counter before each event in that process;
        * When a process sends a message, it includes its counter value with
          the message;
        * On receiving a message, the receiver process sets its counter to be
          greater than the maximum of its own value and the received value
          before it considers the message received.

    Conceptually, this logical clock can be thought of as a clock that only
    has meaning in relation to messages moving between processes.  When a
    process receives a message, it resynchronizes its logical clock with
    the sender.

    See Also:
        * `Lamport timestamps`_

        * `Lamports distributed mutex`_

    .. _`Lamport Timestamps`: https://en.wikipedia.org/wiki/Lamport_timestamps
    .. _`Lamports distributed mutex`: https://bit.ly/p99ybE

    *Usage*

    When sending a message use :meth:`forward` to increment the clock,
    when receiving a message use :meth:`adjust` to sync with
    the time stamp of the incoming message.

    """
    value = ...
    def __init__(self, initial_value=..., Lock=...) -> None:
        ...
    
    def adjust(self, other):
        ...
    
    def forward(self):
        ...
    
    def sort_heap(self, h):
        """Sort heap of events.

        List of tuples containing at least two elements, representing
        an event, where the first element is the event's scalar clock value,
        and the second element is the id of the process (usually
        ``"hostname:pid"``): ``sh([(clock, processid, ...?), (...)])``

        The list must already be sorted, which is why we refer to it as a
        heap.

        The tuple will not be unpacked, so more than two elements can be
        present.

        Will return the latest event.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self):
        ...
    


