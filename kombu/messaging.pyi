"""
This type stub file was generated by pyright.
"""

from .exceptions import ContentDisallowed

"""Sending and receiving messages."""
class Producer:
    """Message Producer.

    Arguments:
        channel (kombu.Connection, ChannelT): Connection or channel.
        exchange (kombu.entity.Exchange, str): Optional default exchange.
        routing_key (str): Optional default routing key.
        serializer (str): Default serializer. Default is `"json"`.
        compression (str): Default compression method.
            Default is no compression.
        auto_declare (bool): Automatically declare the default exchange
            at instantiation. Default is :const:`True`.
        on_return (Callable): Callback to call for undeliverable messages,
            when the `mandatory` or `immediate` arguments to
            :meth:`publish` is used. This callback needs the following
            signature: `(exception, exchange, routing_key, message)`.
            Note that the producer needs to drain events to use this feature.
    """
    exchange = ...
    routing_key = ...
    serializer = ...
    compression = ...
    auto_declare = ...
    on_return = ...
    __connection__ = ...
    def __init__(self, channel, exchange=..., routing_key=..., serializer=..., auto_declare=..., compression=..., on_return=...) -> None:
        ...
    
    def __repr__(self):
        ...
    
    def __reduce__(self):
        ...
    
    def __reduce_args__(self):
        ...
    
    def declare(self):
        """Declare the exchange.

        Note:
            This happens automatically at instantiation when
            the :attr:`auto_declare` flag is enabled.
        """
        ...
    
    def maybe_declare(self, entity, retry=..., **retry_policy):
        """Declare exchange if not already declared during this session."""
        ...
    
    def publish(self, body, routing_key=..., delivery_mode=..., mandatory=..., immediate=..., priority=..., content_type=..., content_encoding=..., serializer=..., headers=..., compression=..., exchange=..., retry=..., retry_policy=..., declare=..., expiration=..., **properties):
        """Publish message to the specified exchange.

        Arguments:
            body (Any): Message body.
            routing_key (str): Message routing key.
            delivery_mode (enum): See :attr:`delivery_mode`.
            mandatory (bool): Currently not supported.
            immediate (bool): Currently not supported.
            priority (int): Message priority. A number between 0 and 9.
            content_type (str): Content type. Default is auto-detect.
            content_encoding (str): Content encoding. Default is auto-detect.
            serializer (str): Serializer to use. Default is auto-detect.
            compression (str): Compression method to use.  Default is none.
            headers (Dict): Mapping of arbitrary headers to pass along
                with the message body.
            exchange (kombu.entity.Exchange, str): Override the exchange.
                Note that this exchange must have been declared.
            declare (Sequence[EntityT]): Optional list of required entities
                that must have been declared before publishing the message.
                The entities will be declared using
                :func:`~kombu.common.maybe_declare`.
            retry (bool): Retry publishing, or declaring entities if the
                connection is lost.
            retry_policy (Dict): Retry configuration, this is the keywords
                supported by :meth:`~kombu.Connection.ensure`.
            expiration (float): A TTL in seconds can be specified per message.
                Default is no expiration.
            **properties (Any): Additional message properties, see AMQP spec.
        """
        ...
    
    channel = ...
    def revive(self, channel):
        """Revive the producer after connection loss."""
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *exc_info):
        ...
    
    def release(self):
        ...
    
    close = ...
    @property
    def connection(self):
        ...
    


class Consumer:
    """Message consumer.

    Arguments:
        channel (kombu.Connection, ChannelT): see :attr:`channel`.
        queues (Sequence[kombu.Queue]): see :attr:`queues`.
        no_ack (bool): see :attr:`no_ack`.
        auto_declare (bool): see :attr:`auto_declare`
        callbacks (Sequence[Callable]): see :attr:`callbacks`.
        on_message (Callable): See :attr:`on_message`
        on_decode_error (Callable): see :attr:`on_decode_error`.
        prefetch_count (int): see :attr:`prefetch_count`.
    """
    ContentDisallowed = ...
    channel = ...
    queues = ...
    no_ack = ...
    auto_declare = ...
    callbacks = ...
    on_message = ...
    on_decode_error = ...
    accept = ...
    prefetch_count = ...
    _queues = ...
    _tags = ...
    def __init__(self, channel, queues=..., no_ack=..., auto_declare=..., callbacks=..., on_decode_error=..., on_message=..., accept=..., prefetch_count=..., tag_prefix=...) -> None:
        ...
    
    def revive(self, channel):
        """Revive consumer after connection loss."""
        ...
    
    def declare(self):
        """Declare queues, exchanges and bindings.

        Note:
            This is done automatically at instantiation
            when :attr:`auto_declare` is set.
        """
        ...
    
    def register_callback(self, callback):
        """Register a new callback to be called when a message is received.

        Note:
            The signature of the callback needs to accept two arguments:
            `(body, message)`, which is the decoded message body
            and the :class:`~kombu.Message` instance.
        """
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        ...
    
    def add_queue(self, queue):
        """Add a queue to the list of queues to consume from.

        Note:
            This will not start consuming from the queue,
            for that you will have to call :meth:`consume` after.
        """
        ...
    
    def consume(self, no_ack=...):
        """Start consuming messages.

        Can be called multiple times, but note that while it
        will consume from new queues added since the last call,
        it will not cancel consuming from removed queues (
        use :meth:`cancel_by_queue`).

        Arguments:
            no_ack (bool): See :attr:`no_ack`.
        """
        ...
    
    def cancel(self):
        """End all active queue consumers.

        Note:
            This does not affect already delivered messages, but it does
            mean the server will not send any more messages for this consumer.
        """
        ...
    
    close = ...
    def cancel_by_queue(self, queue):
        """Cancel consumer by queue name."""
        ...
    
    def consuming_from(self, queue):
        """Return :const:`True` if currently consuming from queue'."""
        ...
    
    def purge(self):
        """Purge messages from all queues.

        Warning:
            This will *delete all ready messages*, there is no undo operation.
        """
        ...
    
    def flow(self, active):
        """Enable/disable flow from peer.

        This is a simple flow-control mechanism that a peer can use
        to avoid overflowing its queues or otherwise finding itself
        receiving more messages than it can process.

        The peer that receives a request to stop sending content
        will finish sending the current content (if any), and then wait
        until flow is reactivated.
        """
        ...
    
    def qos(self, prefetch_size=..., prefetch_count=..., apply_global=...):
        """Specify quality of service.

        The client can request that messages should be sent in
        advance so that when the client finishes processing a message,
        the following message is already held locally, rather than needing
        to be sent down the channel. Prefetching gives a performance
        improvement.

        The prefetch window is Ignored if the :attr:`no_ack` option is set.

        Arguments:
            prefetch_size (int): Specify the prefetch window in octets.
                The server will send a message in advance if it is equal to
                or smaller in size than the available prefetch size (and
                also falls within other prefetch limits). May be set to zero,
                meaning "no specific limit", although other prefetch limits
                may still apply.

            prefetch_count (int): Specify the prefetch window in terms of
                whole messages.

            apply_global (bool): Apply new settings globally on all channels.
        """
        ...
    
    def recover(self, requeue=...):
        """Redeliver unacknowledged messages.

        Asks the broker to redeliver all unacknowledged messages
        on the specified channel.

        Arguments:
            requeue (bool): By default the messages will be redelivered
                to the original recipient. With `requeue` set to true, the
                server will attempt to requeue the message, potentially then
                delivering it to an alternative subscriber.
        """
        ...
    
    def receive(self, body, message):
        """Method called when a message is received.

        This dispatches to the registered :attr:`callbacks`.

        Arguments:
            body (Any): The decoded message body.
            message (~kombu.Message): The message instance.

        Raises:
            NotImplementedError: If no consumer callbacks have been
                registered.
        """
        ...
    
    def __repr__(self):
        ...
    
    @property
    def connection(self):
        ...
    


