"""
This type stub file was generated by pyright.
"""

import os
from contextlib import contextmanager
from itertools import cycle
from .log import get_logger
from .resource import Resource
from .utils.functional import shufflecycle
from .utils.objects import cached_property

"""Client (Connection)."""
logger = get_logger(__name__)
roundrobin_failover = cycle
resolve_aliases = { 'pyamqp': 'amqp','librabbitmq': 'amqp' }
failover_strategies = { 'round-robin': roundrobin_failover,'shuffle': shufflecycle }
_log_connection = os.environ.get('KOMBU_LOG_CONNECTION', False)
_log_channel = os.environ.get('KOMBU_LOG_CHANNEL', False)
class Connection:
    """A connection to the broker.

    Example:
        >>> Connection('amqp://guest:guest@localhost:5672//')
        >>> Connection('amqp://foo;amqp://bar',
        ...            failover_strategy='round-robin')
        >>> Connection('redis://', transport_options={
        ...     'visibility_timeout': 3000,
        ... })

        >>> import ssl
        >>> Connection('amqp://', login_method='EXTERNAL', ssl={
        ...    'ca_certs': '/etc/pki/tls/certs/something.crt',
        ...    'keyfile': '/etc/something/system.key',
        ...    'certfile': '/etc/something/system.cert',
        ...    'cert_reqs': ssl.CERT_REQUIRED,
        ... })

    Note:
        SSL currently only works with the py-amqp, and qpid
        transports.  For other transports you can use stunnel.

    Arguments:
        URL (str, Sequence): Broker URL, or a list of URLs.

    Keyword Arguments:
        ssl (bool): Use SSL to connect to the server. Default is ``False``.
            May not be supported by the specified transport.
        transport (Transport): Default transport if not specified in the URL.
        connect_timeout (float): Timeout in seconds for connecting to the
            server. May not be supported by the specified transport.
        transport_options (Dict): A dict of additional connection arguments to
            pass to alternate kombu channel implementations.  Consult the
            transport documentation for available options.
        heartbeat (float): Heartbeat interval in int/float seconds.
            Note that if heartbeats are enabled then the
            :meth:`heartbeat_check` method must be called regularly,
            around once per second.

    Note:
        The connection is established lazily when needed. If you need the
        connection to be established, then force it by calling
        :meth:`connect`::

            >>> conn = Connection('amqp://')
            >>> conn.connect()

        and always remember to close the connection::

            >>> conn.release()

    These options have been replaced by the URL argument, but are still
    supported for backwards compatibility:

    :keyword hostname: Host name/address.
        NOTE: You cannot specify both the URL argument and use the hostname
        keyword argument at the same time.
    :keyword userid: Default user name if not provided in the URL.
    :keyword password: Default password if not provided in the URL.
    :keyword virtual_host: Default virtual host if not provided in the URL.
    :keyword port: Default port if not provided in the URL.
    """
    port = ...
    virtual_host = ...
    connect_timeout = ...
    _closed = ...
    _connection = ...
    _default_channel = ...
    _transport = ...
    _logger = ...
    uri_prefix = ...
    declared_entities = ...
    cycle = ...
    transport_options = ...
    failover_strategy = ...
    heartbeat = ...
    resolve_aliases = ...
    failover_strategies = ...
    hostname = ...
    def __init__(self, hostname=..., userid=..., password=..., virtual_host=..., port=..., insist=..., ssl=..., transport=..., connect_timeout=..., transport_options=..., login_method=..., uri_prefix=..., heartbeat=..., failover_strategy=..., alternates=..., **kwargs) -> None:
        ...
    
    def switch(self, conn_str):
        """Switch connection parameters to use a new URL or hostname.

        Note:
            Does not reconnect!

        Arguments:
            conn_str (str): either a hostname or URL.
        """
        ...
    
    def maybe_switch_next(self):
        """Switch to next URL given by the current failover strategy."""
        ...
    
    def register_with_event_loop(self, loop):
        ...
    
    def connect(self):
        """Establish connection to server immediately."""
        ...
    
    def channel(self):
        """Create and return a new channel."""
        ...
    
    def heartbeat_check(self, rate=...):
        """Check heartbeats.

        Allow the transport to perform any periodic tasks
        required to make heartbeats work.  This should be called
        approximately every second.

        If the current transport does not support heartbeats then
        this is a noop operation.

        Arguments:
            rate (int): Rate is how often the tick is called
                compared to the actual heartbeat value.  E.g. if
                the heartbeat is set to 3 seconds, and the tick
                is called every 3 / 2 seconds, then the rate is 2.
                This value is currently unused by any transports.
        """
        ...
    
    def drain_events(self, **kwargs):
        """Wait for a single event from the server.

        Arguments:
            timeout (float): Timeout in seconds before we give up.

        Raises:
            socket.timeout: if the timeout is exceeded.
        """
        ...
    
    def maybe_close_channel(self, channel):
        """Close given channel, but ignore connection and channel errors."""
        ...
    
    def collect(self, socket_timeout=...):
        ...
    
    def release(self):
        """Close the connection (if open)."""
        ...
    
    close = ...
    def ensure_connection(self, *args, **kwargs):
        """Public interface of _ensure_connection for retro-compatibility.

        Returns kombu.Connection instance.
        """
        ...
    
    def completes_cycle(self, retries):
        """Return true if the cycle is complete after number of `retries`."""
        ...
    
    def revive(self, new_channel):
        """Revive connection after connection re-established."""
        ...
    
    def ensure(self, obj, fun, errback=..., max_retries=..., interval_start=..., interval_step=..., interval_max=..., on_revive=...):
        """Ensure operation completes.

        Regardless of any channel/connection errors occurring.

        Retries by establishing the connection, and reapplying
        the function.

        Arguments:
            obj: The object to ensure an action on.
            fun (Callable): Method to apply.

            errback (Callable): Optional callback called each time the
                connection can't be established.  Arguments provided are
                the exception raised and the interval that will
                be slept ``(exc, interval)``.

            max_retries (int): Maximum number of times to retry.
                If this limit is exceeded the connection error
                will be re-raised.

            interval_start (float): The number of seconds we start
                sleeping for.
            interval_step (float): How many seconds added to the interval
                for each retry.
            interval_max (float): Maximum number of seconds to sleep between
                each retry.
            on_revive (Callable): Optional callback called whenever
                revival completes successfully

        Examples:
            >>> from kombu import Connection, Producer
            >>> conn = Connection('amqp://')
            >>> producer = Producer(conn)

            >>> def errback(exc, interval):
            ...     logger.error('Error: %r', exc, exc_info=1)
            ...     logger.info('Retry in %s seconds.', interval)

            >>> publish = conn.ensure(producer, producer.publish,
            ...                       errback=errback, max_retries=3)
            >>> publish({'hello': 'world'}, routing_key='dest')
        """
        ...
    
    def autoretry(self, fun, channel=..., **ensure_options):
        """Decorator for functions supporting a ``channel`` keyword argument.

        The resulting callable will retry calling the function if
        it raises connection or channel related errors.
        The return value will be a tuple of ``(retval, last_created_channel)``.

        If a ``channel`` is not provided, then one will be automatically
        acquired (remember to close it afterwards).

        See Also:
            :meth:`ensure` for the full list of supported keyword arguments.

        Example:
            >>> channel = connection.channel()
            >>> try:
            ...    ret, channel = connection.autoretry(
            ...         publish_messages, channel)
            ... finally:
            ...    channel.close()
        """
        class Revival:
            ...
        
        
    
    def create_transport(self):
        ...
    
    def get_transport_cls(self):
        """Get the currently used transport class."""
        ...
    
    def clone(self, **kwargs):
        """Create a copy of the connection with same settings."""
        ...
    
    def get_heartbeat_interval(self):
        ...
    
    def info(self):
        """Get connection info."""
        ...
    
    def __eqhash__(self):
        ...
    
    def as_uri(self, include_password=..., mask=..., getfields=...):
        """Convert connection parameters to URL form."""
        ...
    
    def Pool(self, limit=..., **kwargs):
        """Pool of connections.

        See Also:
            :class:`ConnectionPool`.

        Arguments:
            limit (int): Maximum number of active connections.
                Default is no limit.

        Example:
            >>> connection = Connection('amqp://')
            >>> pool = connection.Pool(2)
            >>> c1 = pool.acquire()
            >>> c2 = pool.acquire()
            >>> c3 = pool.acquire()
            Traceback (most recent call last):
              File "<stdin>", line 1, in <module>
              File "kombu/connection.py", line 354, in acquire
              raise ConnectionLimitExceeded(self.limit)
                kombu.exceptions.ConnectionLimitExceeded: 2
            >>> c1.release()
            >>> c3 = pool.acquire()
        """
        ...
    
    def ChannelPool(self, limit=..., **kwargs):
        """Pool of channels.

        See Also:
            :class:`ChannelPool`.

        Arguments:
            limit (int): Maximum number of active channels.
                Default is no limit.

        Example:
            >>> connection = Connection('amqp://')
            >>> pool = connection.ChannelPool(2)
            >>> c1 = pool.acquire()
            >>> c2 = pool.acquire()
            >>> c3 = pool.acquire()
            Traceback (most recent call last):
              File "<stdin>", line 1, in <module>
              File "kombu/connection.py", line 354, in acquire
              raise ChannelLimitExceeded(self.limit)
                kombu.connection.ChannelLimitExceeded: 2
            >>> c1.release()
            >>> c3 = pool.acquire()
        """
        ...
    
    def Producer(self, channel=..., *args, **kwargs):
        """Create new :class:`kombu.Producer` instance."""
        ...
    
    def Consumer(self, queues=..., channel=..., *args, **kwargs):
        """Create new :class:`kombu.Consumer` instance."""
        ...
    
    def SimpleQueue(self, name, no_ack=..., queue_opts=..., queue_args=..., exchange_opts=..., channel=..., **kwargs):
        """Simple persistent queue API.

        Create new :class:`~kombu.simple.SimpleQueue`, using a channel
        from this connection.

        If ``name`` is a string, a queue and exchange will be automatically
        created using that name as the name of the queue and exchange,
        also it will be used as the default routing key.

        Arguments:
            name (str, kombu.Queue): Name of the queue/or a queue.
            no_ack (bool): Disable acknowledgments. Default is false.
            queue_opts (Dict): Additional keyword arguments passed to the
                constructor of the automatically created :class:`~kombu.Queue`.
            queue_args (Dict): Additional keyword arguments passed to the
                constructor of the automatically created :class:`~kombu.Queue`
                for setting implementation extensions (e.g., in RabbitMQ).
            exchange_opts (Dict): Additional keyword arguments passed to the
                constructor of the automatically created
                :class:`~kombu.Exchange`.
            channel (ChannelT): Custom channel to use. If not specified the
                connection default channel is used.
        """
        ...
    
    def SimpleBuffer(self, name, no_ack=..., queue_opts=..., queue_args=..., exchange_opts=..., channel=..., **kwargs):
        """Simple ephemeral queue API.

        Create new :class:`~kombu.simple.SimpleQueue` using a channel
        from this connection.

        See Also:
            Same as :meth:`SimpleQueue`, but configured with buffering
            semantics. The resulting queue and exchange will not be durable,
            also auto delete is enabled. Messages will be transient (not
            persistent), and acknowledgments are disabled (``no_ack``).
        """
        ...
    
    def supports_exchange_type(self, exchange_type):
        ...
    
    def __repr__(self):
        ...
    
    def __copy__(self):
        ...
    
    def __reduce__(self):
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, *args):
        ...
    
    @property
    def qos_semantics_matches_spec(self):
        ...
    
    @property
    def connected(self):
        """Return true if the connection has been established."""
        ...
    
    @property
    def connection(self):
        """The underlying connection object.

        Warning:
            This instance is transport specific, so do not
            depend on the interface of this object.
        """
        ...
    
    @property
    def default_channel(self):
        """Default channel.

        Created upon access and closed when the connection is closed.

        Note:
            Can be used for automatic channel handling when you only need one
            channel, and also it is the channel implicitly used if
            a connection is passed instead of a channel, to functions that
            require a channel.
        """
        ...
    
    @property
    def host(self):
        """The host as a host name/port pair separated by colon."""
        ...
    
    @property
    def transport(self):
        ...
    
    @cached_property
    def manager(self):
        """AMQP Management API.

        Experimental manager that can be used to manage/monitor the broker
        instance.

        Not available for all transports.
        """
        ...
    
    def get_manager(self, *args, **kwargs):
        ...
    
    @cached_property
    def recoverable_connection_errors(self):
        """Recoverable connection errors.

        List of connection related exceptions that can be recovered from,
        but where the connection must be closed and re-established first.
        """
        ...
    
    @cached_property
    def recoverable_channel_errors(self):
        """Recoverable channel errors.

        List of channel related exceptions that can be automatically
        recovered from without re-establishing the connection.
        """
        ...
    
    @cached_property
    def connection_errors(self):
        """List of exceptions that may be raised by the connection."""
        ...
    
    @cached_property
    def channel_errors(self):
        """List of exceptions that may be raised by the channel."""
        ...
    
    @property
    def supports_heartbeats(self):
        ...
    
    @property
    def is_evented(self):
        ...
    


BrokerConnection = Connection
class ConnectionPool(Resource):
    """Pool of connections."""
    LimitExceeded = ...
    close_after_fork = ...
    def __init__(self, connection, limit=..., **kwargs) -> None:
        ...
    
    def new(self):
        ...
    
    def release_resource(self, resource):
        ...
    
    def close_resource(self, resource):
        ...
    
    def collect_resource(self, resource, socket_timeout=...):
        ...
    
    @contextmanager
    def acquire_channel(self, block=...):
        ...
    
    def setup(self):
        ...
    
    def prepare(self, resource):
        ...
    


class ChannelPool(Resource):
    """Pool of channels."""
    LimitExceeded = ...
    def __init__(self, connection, limit=..., **kwargs) -> None:
        ...
    
    def new(self):
        ...
    
    def setup(self):
        ...
    
    def prepare(self, channel):
        ...
    


def maybe_channel(channel):
    """Get channel from object.

    Return the default channel if argument is a connection instance,
    otherwise just return the channel given.
    """
    ...

def is_connection(obj):
    ...

