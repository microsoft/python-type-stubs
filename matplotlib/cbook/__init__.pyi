from typing import Callable, overload
from matplotlib._typing import *
from matplotlib.artist import Artist

import collections
import collections.abc
import contextlib

class _StrongRef:
    def __init__(self, obj) -> None: ...
    def __call__(self): ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class CallbackRegistry:
    def __init__(
        self, exception_handler: Callable = ..., *, signals: list = ...
    ) -> None: ...
    def __getstate__(self): ...
    def __setstate__(self, state): ...
    def connect(self, signal, func: Callable): ...
    def disconnect(self, cid): ...
    def process(self, s, *args, **kwargs): ...
    @contextlib.contextmanager
    def blocked(self, *, signal: str = ...): ...

class silent_list(list):
    def __init__(self, type, seq=...) -> None: ...
    def __repr__(self): ...

def strip_math(s): ...
def is_writable_file_like(obj): ...
def file_requires_unicode(x): ...
def to_filehandle(
    fname: str | PathLike | FileLike,
    flag: str = "r",
    return_opened: bool = False,
    encoding: str | None = None,
): ...
def open_file_cm(path_or_file: str | PathLike | FileLike, mode=..., encoding=...): ...
def is_scalar_or_string(val) -> bool: ...
@overload
def get_sample_data(
    fname, asfileobj: bool = ..., *, np_load: bool = ...
) -> ArrayLike | tuple | dict: ...
@overload
def get_sample_data(fname, asfileobj: bool, *, np_load=...) -> PathLike: ...
@overload
def get_sample_data(fname, asfileobj: bool = ..., *, np_load=...) -> FileLike: ...
def flatten(seq, scalarp=...): ...

class maxdict(dict):
    def __init__(self, maxsize) -> None: ...
    def __setitem__(self, k, v): ...

class Stack:
    def __init__(self, default=...) -> None: ...
    def __call__(self): ...
    def __len__(self): ...
    def __getitem__(self, ind): ...
    def forward(self): ...
    def back(self): ...
    def push(self, o): ...
    def home(self): ...
    def empty(self) -> bool: ...
    def clear(self): ...
    def bubble(self, o): ...
    def remove(self, o): ...

def report_memory(i=...): ...
def safe_masked_invalid(x, copy=...): ...
def print_cycles(objects, outstream=..., show_progress: bool = ...): ...

class Grouper:
    def __init__(self, init=...) -> None: ...
    def __contains__(self, item): ...
    def clean(self): ...
    def join(self, a, *args): ...
    def joined(self, a, b): ...
    def remove(self, a): ...
    def __iter__(self): ...
    def get_siblings(self, a): ...

class GrouperView:
    def __init__(self, grouper) -> None: ...

    class _GrouperMethodForwarder:
        def __init__(self, deprecated_kw=...) -> None: ...
        def __set_name__(self, owner, name): ...

    joined = ...
    get_siblings = ...
    clean = ...
    join = ...
    remove = ...

def simple_linear_interpolation(a, steps: int) -> list: ...
def delete_masked_points(*args): ...
def boxplot_stats(
    X: ArrayLike,
    whis: float = 1.5,
    bootstrap: int = ...,
    labels: ArrayLike = ...,
    autorange: bool = False,
) -> list[dict]: ...

ls_mapper = ...
ls_mapper_r = ...

def contiguous_regions(mask): ...
def is_math_text(s) -> bool: ...
def violin_stats(
    X: ArrayLike, method: Callable, points: int = ..., quantiles: ArrayLike = ...
) -> list[dict]: ...
def pts_to_prestep(x: list, *args) -> list: ...
def pts_to_poststep(x: list, *args) -> list: ...
def pts_to_midstep(x: list, *args) -> list: ...

STEP_LOOKUP_MAP = ...

def index_of(
    y: float | ArrayLike,
): ...
def safe_first_element(obj): ...
def sanitize_sequence(data): ...
def normalize_kwargs(kw: dict | None, alias_mapping: dict | Artist = ...): ...

class _OrderedSet(collections.abc.MutableSet):
    def __init__(self) -> None: ...
    def __contains__(self, key): ...
    def __iter__(self): ...
    def __len__(self): ...
    def add(self, key): ...
    def discard(self, key): ...
